{"version":3,"sources":["../src/data.ts","../src/utils.ts","../src/parser.ts","../src/index.ts"],"sourcesContent":["/**\n * Address parsing patterns and data for US and Canada\n */\n\n// US and Canadian directional abbreviations\nexport const DIRECTIONAL_MAP: Record<string, string> = {\n  // English\n  'north': 'N',\n  'northeast': 'NE', \n  'east': 'E',\n  'southeast': 'SE',\n  'south': 'S',\n  'southwest': 'SW',\n  'west': 'W',\n  'northwest': 'NW',\n  // Short forms\n  'n': 'N',\n  'ne': 'NE',\n  'e': 'E', \n  'se': 'SE',\n  's': 'S',\n  'sw': 'SW',\n  'w': 'W',\n  'nw': 'NW',\n  // French (for Canada)\n  'nord': 'N',\n  'nord-est': 'NE',\n  'est': 'E',\n  'sud-est': 'SE', \n  'sud': 'S',\n  'sud-ouest': 'SW',\n  'ouest': 'W',\n  'nord-ouest': 'NW',\n};\n\n// US Street Types (USPS official abbreviations)\nexport const US_STREET_TYPES: Record<string, string> = {\n  'alley': 'aly', 'allee': 'aly', 'ally': 'aly',\n  'anex': 'anx', 'annex': 'anx', 'annx': 'anx',\n  'arcade': 'arc',\n  'avenue': 'ave', 'av': 'ave', 'aven': 'ave', 'avenu': 'ave', 'avn': 'ave', 'avnue': 'ave', 'ave': 'ave',\n  'bayou': 'byu', 'bayoo': 'byu',\n  'beach': 'bch',\n  'bend': 'bnd',\n  'bluff': 'blf', 'bluf': 'blf',\n  'bluffs': 'blfs',\n  'bottom': 'btm', 'bot': 'btm', 'bottm': 'btm',\n  'boulevard': 'blvd', 'blvd': 'blvd', 'boul': 'blvd', 'boulv': 'blvd',\n  'branch': 'br', 'brnch': 'br',\n  'bridge': 'brg', 'brdge': 'brg',\n  'brook': 'brk',\n  'brooks': 'brks',\n  'burg': 'bg',\n  'burgs': 'bgs',\n  'bypass': 'byp', 'bypa': 'byp', 'bypas': 'byp', 'byps': 'byp',\n  'camp': 'cp', 'cmp': 'cp',\n  'canyon': 'cyn', 'canyn': 'cyn', 'cnyn': 'cyn',\n  'cape': 'cpe',\n  'causeway': 'cswy', 'causwa': 'cswy',\n  'center': 'ctr', 'cent': 'ctr', 'centr': 'ctr', 'centre': 'ctr', 'cnter': 'ctr', 'cntr': 'ctr',\n  'centers': 'ctrs',\n  'circle': 'cir', 'circ': 'cir', 'circl': 'cir', 'crcl': 'cir', 'crcle': 'cir',\n  'circles': 'cirs',\n  'cliff': 'clf',\n  'cliffs': 'clfs',\n  'club': 'clb',\n  'common': 'cmn',\n  'commons': 'cmns',\n  'corner': 'cor',\n  'corners': 'cors',\n  'course': 'crse',\n  'court': 'ct', 'crt': 'ct',\n  'courts': 'cts',\n  'cove': 'cv',\n  'coves': 'cvs',\n  'creek': 'crk',\n  'crescent': 'cres', 'crsent': 'cres', 'crsnt': 'cres',\n  'crest': 'crst',\n  'crossing': 'xing', 'crssng': 'xing', 'crssing': 'xing',\n  'crossroad': 'xrd',\n  'crossroads': 'xrds',\n  'curve': 'curv',\n  'dale': 'dl',\n  'dam': 'dm',\n  'divide': 'dv', 'div': 'dv', 'dvd': 'dv',\n  'drive': 'dr', 'driv': 'dr', 'drv': 'dr',\n  'drives': 'drs',\n  'estate': 'est',\n  'estates': 'ests',\n  'expressway': 'expy', 'exp': 'expy', 'expr': 'expy', 'express': 'expy', 'expw': 'expy',\n  'extension': 'ext', 'extn': 'ext', 'extnsn': 'ext',\n  'extensions': 'exts',\n  'fall': 'fall',\n  'falls': 'fls',\n  'ferry': 'fry', 'frry': 'fry',\n  'field': 'fld',\n  'fields': 'flds',\n  'flat': 'flt',\n  'flats': 'flts',\n  'ford': 'frd',\n  'fords': 'frds',\n  'forest': 'frst', 'forests': 'frst',\n  'forge': 'frg', 'forg': 'frg',\n  'forges': 'frgs',\n  'fork': 'frk',\n  'forks': 'frks',\n  'fort': 'ft', 'frt': 'ft',\n  'freeway': 'fwy', 'freewy': 'fwy', 'frway': 'fwy', 'frwy': 'fwy',\n  'garden': 'gdn', 'gardn': 'gdn', 'grden': 'gdn', 'grdn': 'gdn',\n  'gardens': 'gdns', 'grdns': 'gdns',\n  'gateway': 'gtwy', 'gatewy': 'gtwy', 'gatway': 'gtwy', 'gtway': 'gtwy',\n  'glen': 'gln',\n  'glens': 'glns',\n  'green': 'grn',\n  'greens': 'grns',\n  'grove': 'grv', 'grov': 'grv',\n  'groves': 'grvs',\n  'harbor': 'hbr', 'harb': 'hbr', 'harbr': 'hbr', 'hrbor': 'hbr',\n  'harbors': 'hbrs',\n  'haven': 'hvn',\n  'heights': 'hts', 'height': 'hts', 'hgts': 'hts', 'ht': 'hts',\n  'highway': 'hwy', 'highwy': 'hwy', 'hiway': 'hwy', 'hiwy': 'hwy', 'hway': 'hwy',\n  'hill': 'hl',\n  'hills': 'hls',\n  'hollow': 'holw', 'hllw': 'holw', 'hollows': 'holw', 'holws': 'holw',\n  'inlet': 'inlt',\n  'island': 'is', 'islnd': 'is',\n  'islands': 'iss', 'islnds': 'iss',\n  'isle': 'isle', 'isles': 'isle',\n  'junction': 'jct', 'jction': 'jct', 'jctn': 'jct', 'junctn': 'jct', 'juncton': 'jct',\n  'junctions': 'jcts', 'jctns': 'jcts',\n  'key': 'ky',\n  'keys': 'kys',\n  'knoll': 'knl', 'knol': 'knl',\n  'knolls': 'knls', 'knols': 'knls',\n  'lake': 'lk',\n  'lakes': 'lks',\n  'land': 'land',\n  'landing': 'lndg', 'lndng': 'lndg',\n  'lane': 'ln', 'lanes': 'ln',\n  'light': 'lgt',\n  'lights': 'lgts',\n  'loaf': 'lf',\n  'lock': 'lck',\n  'locks': 'lcks',\n  'lodge': 'ldg', 'ldge': 'ldg', 'lodg': 'ldg',\n  'loop': 'loop', 'loops': 'loop',\n  'mall': 'mall',\n  'manor': 'mnr', 'manr': 'mnr',\n  'manors': 'mnrs', 'manrs': 'mnrs',\n  'meadow': 'mdw',\n  'meadows': 'mdws', 'medows': 'mdws',\n  'mews': 'mews',\n  'mill': 'ml',\n  'mills': 'mls',\n  'mission': 'msn', 'missn': 'msn', 'mssn': 'msn',\n  'motorway': 'mtwy',\n  'mount': 'mt', 'mnt': 'mt',\n  'mountain': 'mtn', 'mntain': 'mtn', 'mntn': 'mtn', 'mountin': 'mtn', 'mtin': 'mtn',\n  'mountains': 'mtns', 'mntns': 'mtns',\n  'neck': 'nck',\n  'orchard': 'orch', 'orchrd': 'orch',\n  'oval': 'oval',\n  'overpass': 'opas',\n  'park': 'park', 'parks': 'park', 'prk': 'park',\n  'parkway': 'pkwy', 'parkwy': 'pkwy', 'pkway': 'pkwy', 'pky': 'pkwy',\n  'parkways': 'pkwy', 'pkwys': 'pkwy',\n  'pass': 'pass',\n  'passage': 'psge',\n  'path': 'path', 'paths': 'path',\n  'pike': 'pike', 'pikes': 'pike',\n  'pine': 'pne',\n  'pines': 'pnes',\n  'place': 'pl', 'plc': 'pl',\n  'plain': 'pln',\n  'plains': 'plns',\n  'plaza': 'plz', 'plza': 'plz',\n  'point': 'pt',\n  'points': 'pts',\n  'port': 'prt',\n  'ports': 'prts',\n  'prairie': 'pr', 'prarie': 'pr', 'prr': 'pr',\n  'radial': 'radl', 'rad': 'radl',\n  'ramp': 'ramp',\n  'ranch': 'rnch', 'ranches': 'rnch', 'rnchs': 'rnch',\n  'rapid': 'rpd',\n  'rapids': 'rpds',\n  'rest': 'rst',\n  'ridge': 'rdg', 'rdge': 'rdg',\n  'ridges': 'rdgs',\n  'river': 'riv', 'rivr': 'riv', 'rvr': 'riv',\n  'road': 'rd', 'roads': 'rds',\n  'route': 'rte',\n  'row': 'row',\n  'rue': 'rue',\n  'run': 'run',\n  'shoal': 'shl',\n  'shoals': 'shls',\n  'shore': 'shr', 'shoar': 'shr',\n  'shores': 'shrs', 'shoars': 'shrs',\n  'skyway': 'skwy',\n  'spring': 'spg', 'spng': 'spg', 'sprng': 'spg',\n  'springs': 'spgs', 'spngs': 'spgs', 'sprngs': 'spgs',\n  'spur': 'spur', 'spurs': 'spur',\n  'square': 'sq', 'sqr': 'sq', 'sqre': 'sq', 'squ': 'sq',\n  'squares': 'sqs', 'sqrs': 'sqs',\n  'station': 'sta', 'statn': 'sta', 'stn': 'sta',\n  'stravenue': 'stra', 'strav': 'stra', 'straven': 'stra', 'strvn': 'stra', 'strvnue': 'stra',\n  'stream': 'strm', 'streme': 'strm',\n  'street': 'st', 'strt': 'st', 'str': 'st', 'st': 'st', 'streets': 'sts',\n  'summit': 'smt', 'sumit': 'smt', 'sumitt': 'smt',\n  'terrace': 'ter', 'terr': 'ter',\n  'throughway': 'trwy',\n  'trace': 'trce', 'traces': 'trce',\n  'track': 'trak', 'tracks': 'trak', 'trk': 'trak', 'trks': 'trak',\n  'trafficway': 'trfy',\n  'trail': 'trl', 'trails': 'trl', 'trls': 'trl',\n  'trailer': 'trlr', 'trlrs': 'trlr',\n  'tunnel': 'tunl', 'tunel': 'tunl', 'tunls': 'tunl', 'tunnels': 'tunl', 'tunnl': 'tunl',\n  'turnpike': 'tpke', 'trnpk': 'tpke', 'turnpk': 'tpke',\n  'underpass': 'upas',\n  'union': 'un',\n  'unions': 'uns',\n  'valley': 'vly', 'vally': 'vly', 'vlly': 'vly',\n  'valleys': 'vlys',\n  'viaduct': 'via', 'vdct': 'via', 'viadct': 'via',\n  'view': 'vw',\n  'views': 'vws',\n  'village': 'vlg', 'vill': 'vlg', 'villag': 'vlg', 'villg': 'vlg', 'villiage': 'vlg',\n  'villages': 'vlgs',\n  'ville': 'vl',\n  'vista': 'vis', 'vist': 'vis', 'vst': 'vis', 'vsta': 'vis',\n  'walk': 'walk',\n  'walks': 'walk',\n  'wall': 'wall',\n  'way': 'way', 'wy': 'way',\n  'ways': 'ways',\n  'well': 'wl',\n  'wells': 'wls',\n};\n\n// Canadian Street Types (Canada Post official abbreviations) - bilingual\nexport const CA_STREET_TYPES: Record<string, string> = {\n  // English\n  'avenue': 'ave',\n  'av': 'ave',\n  'boulevard': 'blvd',\n  'blvd': 'blvd',\n  'boul': 'blvd',\n  'circle': 'cir', \n  'circ': 'cir',\n  'court': 'crt', \n  'ct': 'crt',\n  'crescent': 'cres', \n  'cres': 'cres',\n  'drive': 'dr', \n  'dr': 'dr',\n  'expressway': 'expy',\n  'freeway': 'fwy',\n  'gardens': 'gdns',\n  'gate': 'gate',\n  'grove': 'grove',\n  'heights': 'hts',\n  'highway': 'hwy',\n  'hill': 'hill',\n  'lane': 'lane',\n  'park': 'pk',\n  'parkway': 'pky',\n  'place': 'pl',\n  'plaza': 'plaza',\n  'point': 'pt',\n  'road': 'rd',\n  'route': 'rte',\n  'square': 'sq',\n  'street': 'st',\n  'terrace': 'terr',\n  'trail': 'trail',\n  'way': 'way',\n  // French\n  'autoroute': 'aut',\n  'carrefour': 'carref',\n  'chemin': 'ch',\n  'cercle': 'cir',\n  'côte': 'côte',\n  'cour': 'cour',\n  'croissant': 'crois',\n  'impasse': 'imp',\n  'montée': 'mtée',\n  'passage': 'pass',\n  'promenade': 'prom',\n  'rang': 'rang',\n  'rue': 'rue',\n  'ruelle': 'rle',\n  'sentier': 'sent',\n  'terrasse': 'terr',\n  'voie': 'voie',\n};\n\n// US States\nexport const US_STATES: Record<string, string> = {\n  'alabama': 'AL', 'alaska': 'AK', 'arizona': 'AZ', 'arkansas': 'AR', 'california': 'CA',\n  'colorado': 'CO', 'connecticut': 'CT', 'delaware': 'DE', 'florida': 'FL', 'georgia': 'GA',\n  'hawaii': 'HI', 'idaho': 'ID', 'illinois': 'IL', 'indiana': 'IN', 'iowa': 'IA',\n  'kansas': 'KS', 'kentucky': 'KY', 'louisiana': 'LA', 'maine': 'ME', 'maryland': 'MD',\n  'massachusetts': 'MA', 'michigan': 'MI', 'minnesota': 'MN', 'mississippi': 'MS',\n  'missouri': 'MO', 'montana': 'MT', 'nebraska': 'NE', 'nevada': 'NV', 'new hampshire': 'NH',\n  'new jersey': 'NJ', 'new mexico': 'NM', 'new york': 'NY', 'north carolina': 'NC',\n  'north dakota': 'ND', 'ohio': 'OH', 'oklahoma': 'OK', 'oregon': 'OR', 'pennsylvania': 'PA',\n  'rhode island': 'RI', 'south carolina': 'SC', 'south dakota': 'SD', 'tennessee': 'TN',\n  'texas': 'TX', 'utah': 'UT', 'vermont': 'VT', 'virginia': 'VA', 'washington': 'WA',\n  'west virginia': 'WV', 'wisconsin': 'WI', 'wyoming': 'WY',\n  'district of columbia': 'DC', 'puerto rico': 'PR', 'virgin islands': 'VI',\n  'american samoa': 'AS', 'guam': 'GU', 'northern mariana islands': 'MP',\n};\n\n// Canadian Provinces/Territories  \nexport const CA_PROVINCES: Record<string, string> = {\n  'alberta': 'AB', 'british columbia': 'BC', 'manitoba': 'MB', 'new brunswick': 'NB',\n  'newfoundland and labrador': 'NL', 'northwest territories': 'NT', 'nova scotia': 'NS',\n  'nunavut': 'NU', 'ontario': 'ON', 'prince edward island': 'PE', 'quebec': 'QC',\n  'saskatchewan': 'SK', 'yukon': 'YT',\n  // French names\n  'colombie-britannique': 'BC', 'île-du-prince-édouard': 'PE', 'nouvelle-écosse': 'NS',\n  'nouveau-brunswick': 'NB', 'terre-neuve-et-labrador': 'NL', 'territoires du nord-ouest': 'NT',\n  'québec': 'QC',\n};\n\n// Secondary unit types\nexport const SECONDARY_UNIT_TYPES: Record<string, string> = {\n  'apartment': 'apt', 'apt': 'apt', 'apartme': 'apt',\n  'basement': 'bsmt', 'bsmt': 'bsmt',\n  'building': 'bldg', 'bldg': 'bldg', 'bld': 'bldg',\n  'department': 'dept', 'dept': 'dept',\n  'floor': 'fl', 'fl': 'fl', 'flr': 'fl',\n  'front': 'frnt', 'frnt': 'frnt',\n  'hanger': 'hngr', 'hngr': 'hngr',\n  'key': 'key',\n  'lobby': 'lbby', 'lbby': 'lbby',\n  'lot': 'lot',\n  'lower': 'lowr', 'lowr': 'lowr',\n  'office': 'ofc', 'ofc': 'ofc',\n  'penthouse': 'ph', 'ph': 'ph',\n  'pier': 'pier',\n  'rear': 'rear',\n  'room': 'rm', 'rm': 'rm',\n  'side': 'side',\n  'slip': 'slip',\n  'space': 'spc', 'spc': 'spc',\n  'stop': 'stop',\n  'suite': 'ste', 'ste': 'ste', 'su': 'ste',\n  'trailer': 'trlr', 'trlr': 'trlr',\n  'unit': 'unit',\n  'upper': 'uppr', 'uppr': 'uppr',\n};\n\n// ZIP code patterns\nexport const ZIP_CODE_PATTERN = /^(\\d{5})(?:[-\\s]?(\\d{4}))?$/;\nexport const CANADIAN_POSTAL_CODE_PATTERN = /^([A-Za-z]\\d[A-Za-z])\\s?(\\d[A-Za-z]\\d)$/;\n\n// Common facility name patterns\nexport const FACILITY_PATTERNS = [\n  /\\b(hospital|medical center|clinic|mall|shopping center|plaza|tower|building|center|centre)\\b/i,\n  /\\b(school|university|college|library|church|temple|mosque|synagogue)\\b/i,\n  /\\b(airport|station|terminal|depot|port|harbor|harbour)\\b/i,\n  /\\b(park|recreation|rec center|community center|civic center)\\b/i,\n];","/**\n * Core parsing utilities and regex patterns\n */\n\nimport {\n  DIRECTIONAL_MAP,\n  US_STREET_TYPES,\n  CA_STREET_TYPES,\n  US_STATES,\n  CA_PROVINCES,\n  SECONDARY_UNIT_TYPES,\n  ZIP_CODE_PATTERN,\n  CANADIAN_POSTAL_CODE_PATTERN,\n  FACILITY_PATTERNS,\n} from './data';\nimport { ParsedAddress, ParseOptions } from './types';\n\n/**\n * Normalize text for consistent parsing\n */\nexport function normalizeText(text: string): string {\n  return text\n    .toLowerCase()\n    .replace(/\\s+/g, ' ')\n    .replace(/[.,;]/g, ' ')\n    .trim();\n}\n\n/**\n * Build regex patterns from dictionary\n */\nexport function buildRegexFromDict(dict: Record<string, string>, capture = true): RegExp {\n  const keys = Object.keys(dict).sort((a, b) => b.length - a.length);\n  const pattern = keys.map(key => key.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')).join('|');\n  return new RegExp(capture ? `\\\\b(${pattern})\\\\b` : `\\\\b(?:${pattern})\\\\b`, 'i');\n}\n\n/**\n * Extract and normalize directional\n */\nexport function parseDirectional(text: string): { direction: string | undefined; remaining: string } {\n  const dirPattern = buildRegexFromDict(DIRECTIONAL_MAP);\n  const match = text.match(dirPattern);\n  \n  if (match) {\n    const direction = DIRECTIONAL_MAP[match[1].toLowerCase()];\n    const remaining = text.replace(dirPattern, ' ').replace(/\\s+/g, ' ').trim();\n    return { direction, remaining };\n  }\n  \n  return { direction: undefined, remaining: text };\n}\n\n/**\n * Extract and normalize street type\n */\nexport function parseStreetType(text: string, country: 'US' | 'CA' = 'US'): { type: string | undefined; remaining: string } {\n  const typeMap = country === 'CA' ? { ...US_STREET_TYPES, ...CA_STREET_TYPES } : US_STREET_TYPES;\n  const typePattern = buildRegexFromDict(typeMap);\n  const match = text.match(typePattern);\n  \n  if (match) {\n    const type = typeMap[match[1].toLowerCase()];\n    const remaining = text.replace(typePattern, ' ').replace(/\\s+/g, ' ').trim();\n    return { type, remaining };\n  }\n  \n  return { type: undefined, remaining: text };\n}\n\n/**\n * Extract state or province  \n */\nexport function parseStateProvince(text: string, country?: 'US' | 'CA'): { state: string | undefined; remaining: string; detectedCountry?: 'US' | 'CA' } {\n  // Try US state abbreviations first (more specific than full names)\n  const usAbbrevPattern = new RegExp(`\\\\b(${Object.values(US_STATES).join('|')})\\\\b`, 'i');\n  let match = text.match(usAbbrevPattern);\n  if (match) {\n    const state = match[1].toUpperCase();\n    const remaining = text.replace(new RegExp(`\\\\b${match[1].replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'i'), ' ').replace(/\\s+/g, ' ').trim();\n    return { state, remaining, detectedCountry: 'US' };\n  }\n  \n  // Try Canadian province abbreviations\n  const caAbbrevPattern = new RegExp(`\\\\b(${Object.values(CA_PROVINCES).join('|')})\\\\b`, 'i');\n  match = text.match(caAbbrevPattern);\n  if (match) {\n    const state = match[1].toUpperCase();\n    const remaining = text.replace(new RegExp(`\\\\b${match[1].replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'i'), ' ').replace(/\\s+/g, ' ').trim();\n    return { state, remaining, detectedCountry: 'CA' };\n  }\n  \n  // Try US states full names (only if no abbreviation found)\n  const usPattern = buildRegexFromDict(US_STATES);\n  match = text.match(usPattern);\n  if (match) {\n    const state = US_STATES[match[1].toLowerCase()];\n    const remaining = text.replace(new RegExp(`\\\\b${match[1].replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'gi'), ' ').replace(/\\s+/g, ' ').trim();\n    return { state, remaining, detectedCountry: 'US' };\n  }\n  \n  // Try Canadian provinces full names\n  const caPattern = buildRegexFromDict(CA_PROVINCES);\n  match = text.match(caPattern);\n  if (match) {\n    const state = CA_PROVINCES[match[1].toLowerCase()];\n    const remaining = text.replace(new RegExp(`\\\\b${match[1].replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'gi'), ' ').replace(/\\s+/g, ' ').trim();\n    return { state, remaining, detectedCountry: 'CA' };\n  }\n  \n  return { state: undefined, remaining: text };\n}\n\n/**\n * Extract ZIP or postal code\n */\nexport function parsePostalCode(text: string): { zip: string | undefined; zipext: string | undefined; remaining: string; detectedCountry?: 'US' | 'CA' } {\n  // Try US ZIP code - look for it anywhere in the text\n  const zipMatch = text.match(/\\b(\\d{5})(?:[-\\s]?(\\d{4}))?\\b/);\n  if (zipMatch) {\n    const zip = zipMatch[1];\n    const zipext = zipMatch[2];\n    const remaining = text.replace(zipMatch[0], ' ').replace(/\\s+/g, ' ').trim();\n    return { zip, zipext, remaining, detectedCountry: 'US' };\n  }\n  \n  // Try Canadian postal code - look for it anywhere in the text\n  const postalMatch = text.match(/\\b([A-Za-z]\\d[A-Za-z])\\s?(\\d[A-Za-z]\\d)\\b/);\n  if (postalMatch) {\n    const zip = `${postalMatch[1]} ${postalMatch[2]}`.toUpperCase();\n    const remaining = text.replace(postalMatch[0], ' ').replace(/\\s+/g, ' ').trim();\n    return { zip, zipext: undefined, remaining, detectedCountry: 'CA' };\n  }\n  \n  return { zip: undefined, zipext: undefined, remaining: text };\n}\n\n/**\n * Extract secondary unit information\n */\nexport function parseSecondaryUnit(text: string): { \n  unit: string | undefined; \n  sec_unit_type: string | undefined; \n  sec_unit_num: string | undefined; \n  remaining: string;\n} {\n  const unitPattern = buildRegexFromDict(SECONDARY_UNIT_TYPES);\n  \n  // Look for unit type followed by number\n  const unitMatch = text.match(new RegExp(`${unitPattern.source}\\\\s*(\\\\d+\\\\w*|[a-zA-Z]+\\\\d*)`));\n  if (unitMatch) {\n    const sec_unit_type = SECONDARY_UNIT_TYPES[unitMatch[1].toLowerCase()];\n    const sec_unit_num = unitMatch[2];\n    const unit = `${sec_unit_type} ${sec_unit_num}`;\n    const remaining = text.replace(unitMatch[0], ' ').replace(/\\s+/g, ' ').trim();\n    return { unit, sec_unit_type, sec_unit_num, remaining };\n  }\n  \n  // Look for just numbers that might be unit numbers\n  const numberMatch = text.match(/\\b(apt|apartment|unit|ste|suite|#)\\s*(\\d+\\w*)\\b/i);\n  if (numberMatch) {\n    const sec_unit_type = SECONDARY_UNIT_TYPES[numberMatch[1].toLowerCase()] || numberMatch[1].toLowerCase();\n    const sec_unit_num = numberMatch[2];\n    const unit = `${sec_unit_type} ${sec_unit_num}`;\n    const remaining = text.replace(numberMatch[0], ' ').replace(/\\s+/g, ' ').trim();\n    return { unit, sec_unit_type, sec_unit_num, remaining };\n  }\n  \n  return { unit: undefined, sec_unit_type: undefined, sec_unit_num: undefined, remaining: text };\n}\n\n/**\n * Extract facility names\n */\nexport function parseFacility(text: string): { facility: string | undefined; remaining: string } {\n  for (const pattern of FACILITY_PATTERNS) {\n    const match = text.match(pattern);\n    if (match) {\n      // Try to extract the full facility name (word before + match + word after if relevant)\n      const fullMatch = text.match(new RegExp(`\\\\b[\\\\w\\\\s]*${match[0]}[\\\\w\\\\s]*\\\\b`, 'i'));\n      if (fullMatch) {\n        const facility = fullMatch[0].trim();\n        const remaining = text.replace(fullMatch[0], ' ').replace(/\\s+/g, ' ').trim();\n        return { facility, remaining };\n      }\n    }\n  }\n  \n  return { facility: undefined, remaining: text };\n}\n\n/**\n * Parse parenthetical information\n */\nexport function parseParenthetical(text: string): { secondary: string | undefined; remaining: string } {\n  const parenMatch = text.match(/\\(([^)]+)\\)/);\n  if (parenMatch) {\n    const secondary = parenMatch[1].trim();\n    const remaining = text.replace(parenMatch[0], ' ').replace(/\\s+/g, ' ').trim();\n    return { secondary, remaining };\n  }\n  \n  return { secondary: undefined, remaining: text };\n}\n\n/**\n * Extract street number (including fractional)\n */\nexport function parseStreetNumber(text: string): { number: string | undefined; remaining: string } {\n  // Handle fractional numbers like \"123 1/2\" or \"123-1/2\"\n  const fracMatch = text.match(/^\\s*(\\d+(?:\\s*[-\\/]\\s*\\d+\\/\\d+|\\s+\\d+\\/\\d+)?)\\b/);\n  if (fracMatch) {\n    const number = fracMatch[1].replace(/\\s+/g, ' ').trim();\n    const remaining = text.replace(fracMatch[0], ' ').replace(/\\s+/g, ' ').trim();\n    return { number, remaining };\n  }\n  \n  // Handle simple numbers\n  const numMatch = text.match(/^\\s*(\\d+)\\b/);\n  if (numMatch) {\n    const number = numMatch[1];\n    const remaining = text.replace(numMatch[0], ' ').replace(/\\s+/g, ' ').trim();\n    return { number, remaining };\n  }\n  \n  return { number: undefined, remaining: text };\n}\n\n/**\n * Detect country from address components\n */\nexport function detectCountry(address: ParsedAddress): 'US' | 'CA' | undefined {\n  if (address.state) {\n    if (Object.values(US_STATES).includes(address.state) || Object.keys(US_STATES).includes(address.state.toLowerCase())) {\n      return 'US';\n    }\n    if (Object.values(CA_PROVINCES).includes(address.state) || Object.keys(CA_PROVINCES).includes(address.state.toLowerCase())) {\n      return 'CA';\n    }\n  }\n  \n  if (address.zip) {\n    if (ZIP_CODE_PATTERN.test(address.zip)) {\n      return 'US';\n    }\n    if (CANADIAN_POSTAL_CODE_PATTERN.test(address.zip)) {\n      return 'CA';\n    }\n  }\n  \n  return undefined;\n}","/**\n * Main address parser implementation\n */\n\nimport { ParsedAddress, ParsedIntersection, ParseOptions, AddressParser } from './types';\nimport {\n  normalizeText,\n  parseDirectional,\n  parseStreetType,\n  parseStateProvince,\n  parsePostalCode,\n  parseSecondaryUnit,\n  parseFacility,\n  parseParenthetical,\n  parseStreetNumber,\n  detectCountry,\n} from './utils';\nimport { \n  US_STREET_TYPES, \n  CA_STREET_TYPES, \n  US_STATES, \n  CA_PROVINCES,\n  SECONDARY_UNIT_TYPES,\n  DIRECTIONAL_MAP\n} from './data';\n\n/**\n * Parse a location string into address components\n */\nexport function parseLocation(address: string, options: ParseOptions = {}): ParsedAddress | null {\n  if (!address || typeof address !== 'string') {\n    return null;\n  }\n\n  const {\n    country = 'auto',\n    normalize = true,\n    validatePostalCode = true,\n    language = 'auto',\n    extractFacilities = true,\n    parseParenthetical: enableParenthetical = true,\n  } = options;\n\n  const original = address.trim();\n  const result: ParsedAddress = {};\n\n  // Split by comma FIRST before any normalization that removes commas\n  const parts = original.split(',').map(p => p.trim()).filter(Boolean);\n  \n  let streetPart = '';\n  let cityPart = '';\n  let stateZipPart = '';\n\n  if (parts.length >= 3) {\n    // Format: \"street, city, state zip\"\n    streetPart = parts[0];\n    cityPart = parts[1]; \n    stateZipPart = parts.slice(2).join(' ');\n  } else if (parts.length >= 2) {\n    streetPart = parts[0];\n    stateZipPart = parts[1]; // Could be \"city state zip\" or just \"state zip\"\n  } else if (parts.length === 1) {\n    streetPart = parts[0]; // Parse everything from one part\n  }\n\n  // Now normalize the working text (this will be used for facilities, parenthetical, etc.)\n  let workingText = original.toLowerCase().replace(/[.,;]/g, ' ').replace(/\\s+/g, ' ').trim();\n\n  // Parse parenthetical information first if enabled\n  if (enableParenthetical) {\n    const parenMatch = workingText.match(/\\(([^)]+)\\)/);\n    if (parenMatch) {\n      result.secondary = parenMatch[1].trim();\n      workingText = workingText.replace(parenMatch[0], ' ').replace(/\\s+/g, ' ').trim();\n    }\n  }\n\n  // Extract facility names if enabled\n  if (extractFacilities) {\n    const facilityPatterns = [\n      /\\b(hospital|medical center|clinic|mall|shopping center|plaza|tower|building|center|centre)\\b/i,\n      /\\b(school|university|college|library|church|temple|mosque|synagogue)\\b/i,\n    ];\n    \n    for (const pattern of facilityPatterns) {\n      const match = workingText.match(pattern);\n      if (match) {\n        const fullMatch = workingText.match(new RegExp(`\\\\b[\\\\w\\\\s]*${match[0]}[\\\\w\\\\s]*\\\\b`, 'i'));\n        if (fullMatch) {\n          result.facility = fullMatch[0].trim();\n          workingText = workingText.replace(fullMatch[0], ' ').replace(/\\s+/g, ' ').trim();\n          break;\n        }\n      }\n    }\n  }\n\n  // Extract ZIP/Postal code from stateZipPart or original\n  let sourceForZip = stateZipPart || original;\n  const zipMatch = sourceForZip.match(/\\b(\\d{5})(?:[-\\s]?(\\d{4}))?\\b/);\n  const postalMatch = sourceForZip.match(/\\b([A-Za-z]\\d[A-Za-z])\\s?(\\d[A-Za-z]\\d)\\b/);\n  \n  if (zipMatch) {\n    result.zip = zipMatch[1];\n    if (zipMatch[2]) result.zipext = zipMatch[2];\n    result.country = 'US';\n    if (stateZipPart) {\n      stateZipPart = stateZipPart.replace(new RegExp(zipMatch[0].replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'i'), ' ').replace(/\\s+/g, ' ').trim();\n    } else {\n      // Remove from streetPart if no separate stateZipPart\n      streetPart = streetPart.replace(new RegExp(zipMatch[0].replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'i'), ' ').replace(/\\s+/g, ' ').trim();\n    }\n  } else if (postalMatch) {\n    result.zip = `${postalMatch[1]} ${postalMatch[2]}`.toUpperCase();\n    result.country = 'CA';\n    if (stateZipPart) {\n      stateZipPart = stateZipPart.replace(new RegExp(postalMatch[0].replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'i'), ' ').replace(/\\s+/g, ' ').trim();\n    } else {\n      streetPart = streetPart.replace(new RegExp(postalMatch[0].replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'i'), ' ').replace(/\\s+/g, ' ').trim();\n    }\n  }\n\n  // Extract state/province from stateZipPart or original\n  const usStates = Object.values(US_STATES).join('|');\n  const caProvinces = Object.values(CA_PROVINCES).join('|');\n  \n  let sourceForState = stateZipPart || streetPart;\n  const stateMatch = sourceForState.match(new RegExp(`\\\\b(${usStates}|${caProvinces})\\\\b`, 'i'));\n  if (stateMatch) {\n    result.state = stateMatch[1].toUpperCase();\n    if (!result.country) {\n      result.country = Object.values(US_STATES).includes(result.state) ? 'US' : 'CA';\n    }\n    if (stateZipPart) {\n      stateZipPart = stateZipPart.replace(new RegExp(`\\\\b${stateMatch[1]}\\\\b`, 'i'), ' ').replace(/\\s+/g, ' ').trim();\n    } else {\n      streetPart = streetPart.replace(new RegExp(`\\\\b${stateMatch[1]}\\\\b`, 'i'), ' ').replace(/\\s+/g, ' ').trim();\n    }\n  }\n\n  // If we had a 2-part split and stateZipPart has remaining text after removing state/zip, that's the city\n  if (parts.length === 2 && stateZipPart && stateZipPart.trim()) {\n    cityPart = stateZipPart.trim();\n  }\n\n  // Parse street components\n  if (streetPart) {\n    // Extract street number\n    const numMatch = streetPart.match(/^(\\d+(?:\\s*[-\\/]\\s*\\d+\\/\\d+|\\s+\\d+\\/\\d+)?)/);\n    if (numMatch) {\n      result.number = numMatch[1].trim();\n      streetPart = streetPart.replace(numMatch[0], ' ').trim();\n    }\n\n    // Extract secondary unit\n    const unitMatch = streetPart.match(/\\b(apt|apartment|unit|ste|suite|#)\\s*(\\d+\\w*)/i);\n    if (unitMatch) {\n      const unitType = SECONDARY_UNIT_TYPES[unitMatch[1].toLowerCase()] || unitMatch[1].toLowerCase();\n      result.sec_unit_type = unitType;\n      result.sec_unit_num = unitMatch[2];\n      result.unit = `${unitType} ${unitMatch[2]}`;\n      streetPart = streetPart.replace(unitMatch[0], ' ').trim();\n    }\n\n    // Extract directional prefix\n    const dirWords = Object.keys(DIRECTIONAL_MAP).join('|');\n    const prefixMatch = streetPart.match(new RegExp(`^(${dirWords})\\\\s+`, 'i'));\n    if (prefixMatch) {\n      result.prefix = DIRECTIONAL_MAP[prefixMatch[1].toLowerCase()];\n      streetPart = streetPart.replace(prefixMatch[0], ' ').trim();\n    }\n\n    // Extract street type and suffix\n    const streetTypes = result.country === 'CA' ? {...US_STREET_TYPES, ...CA_STREET_TYPES} : US_STREET_TYPES;\n    const streetWords = streetPart.split(/\\s+/);\n    let typeIndex = -1;\n\n    // Find street type - prioritize later positions and common abbreviations\n    for (let i = streetWords.length - 1; i >= 0; i--) {\n      const word = streetWords[i].toLowerCase();\n      if (streetTypes[word]) {\n        // Additional check: if this is a common street name that's also a type, skip it unless it's in a typical type position\n        if (word === 'pine' || word === 'oak' || word === 'maple' || word === 'cedar') {\n          // These are common street names, only treat as type if they're at the end or followed by directional\n          if (i === streetWords.length - 1 || \n              (i === streetWords.length - 2 && DIRECTIONAL_MAP[streetWords[i + 1].toLowerCase()])) {\n            result.type = streetTypes[word];\n            typeIndex = i;\n            break;\n          }\n        } else {\n          result.type = streetTypes[word];\n          typeIndex = i;\n          break;\n        }\n      }\n    }\n\n    if (typeIndex >= 0) {\n      // Check for suffix directional after street type\n      let suffixIndex = -1;\n      if (typeIndex + 1 < streetWords.length) {\n        const suffixCandidate = streetWords[typeIndex + 1].toLowerCase();\n        if (DIRECTIONAL_MAP[suffixCandidate]) {\n          result.suffix = DIRECTIONAL_MAP[suffixCandidate];\n          suffixIndex = typeIndex + 1;\n        }\n      }\n\n      // Street name is everything before the type\n      if (typeIndex > 0) {\n        result.street = streetWords.slice(0, typeIndex).join(' ');\n      }\n\n      // If there's text after the type (and suffix), it might be city\n      const remainingStart = suffixIndex >= 0 ? suffixIndex + 1 : typeIndex + 1;\n      if (remainingStart < streetWords.length && !cityPart) {\n        cityPart = streetWords.slice(remainingStart).join(' ');\n      }\n    } else {\n      // No street type found, assume it's all street name\n      result.street = streetPart;\n    }\n  }\n\n  // Set city  \n  if (cityPart) {\n    result.city = cityPart;\n  }\n\n  // Auto-detect country if not set\n  if (!result.country && result.state) {\n    result.country = Object.values(US_STATES).includes(result.state) ? 'US' : 'CA';\n  }\n\n  // Validate postal code if requested\n  if (validatePostalCode && result.zip && result.country) {\n    const isValid = result.country === 'US' \n      ? /^\\d{5}(?:-\\d{4})?$/.test(result.zip)\n      : /^[A-Za-z]\\d[A-Za-z]\\s?\\d[A-Za-z]\\d$/.test(result.zip);\n    \n    if (!isValid) {\n      delete result.zip;\n      delete result.zipext;\n    }\n  }\n\n  // Capitalize names appropriately\n  if (result.street) {\n    result.street = result.street.split(' ').map(word => \n      word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()\n    ).join(' ');\n  }\n  \n  if (result.city) {\n    result.city = result.city.split(' ').map(word => \n      word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()\n    ).join(' ');\n  }\n\n  // Return only if we have meaningful components\n  const hasComponents = result.number || result.street || result.city || result.state || result.zip;\n  return hasComponents ? result : null;\n}\n\n/**\n * Parse an intersection string\n */\nexport function parseIntersection(address: string, options: ParseOptions = {}): ParsedIntersection | null {\n  if (!address || typeof address !== 'string') {\n    return null;\n  }\n\n  const text = normalizeText(address);\n  const result: ParsedIntersection = {};\n\n  // Look for intersection indicators\n  const intersectionMarkers = /\\b(?:and|&|at|@|\\/|\\\\|intersection of|corner of)\\b/i;\n  const match = text.match(intersectionMarkers);\n  \n  if (!match) {\n    return null; // No intersection indicator found\n  }\n\n  const parts = text.split(intersectionMarkers);\n  if (parts.length !== 2) {\n    return null;\n  }\n\n  const street1Text = parts[0].trim();\n  const street2Text = parts[1].trim();\n\n  // Parse each street\n  const parseCountry = options.country !== 'auto' ? options.country : 'US';\n\n  // Parse first street\n  let s1Text = street1Text;\n  const s1PrefixResult = parseDirectional(s1Text);\n  if (s1PrefixResult.direction) {\n    result.prefix1 = s1PrefixResult.direction;\n    s1Text = s1PrefixResult.remaining;\n  }\n\n  const s1TypeResult = parseStreetType(s1Text, parseCountry);\n  if (s1TypeResult.type) {\n    result.type1 = s1TypeResult.type;\n    s1Text = s1TypeResult.remaining;\n  }\n\n  const s1SuffixResult = parseDirectional(s1Text);\n  if (s1SuffixResult.direction) {\n    result.suffix1 = s1SuffixResult.direction;\n    s1Text = s1SuffixResult.remaining;\n  }\n\n  if (s1Text.trim()) {\n    result.street1 = s1Text.trim();\n  }\n\n  // Parse second street (may include city, state, zip)\n  let s2Text = street2Text;\n  \n  // Extract postal code from second street\n  const postalResult = parsePostalCode(s2Text);\n  if (postalResult.zip) {\n    result.zip = postalResult.zip;\n    s2Text = postalResult.remaining;\n  }\n\n  // Extract state from second street\n  const stateResult = parseStateProvince(s2Text);\n  if (stateResult.state) {\n    result.state = stateResult.state;\n    s2Text = stateResult.remaining;\n    \n    if (stateResult.detectedCountry) {\n      result.country = stateResult.detectedCountry;\n    }\n  }\n\n  const s2PrefixResult = parseDirectional(s2Text);\n  if (s2PrefixResult.direction) {\n    result.prefix2 = s2PrefixResult.direction;\n    s2Text = s2PrefixResult.remaining;\n  }\n\n  const s2TypeResult = parseStreetType(s2Text, parseCountry);\n  if (s2TypeResult.type) {\n    result.type2 = s2TypeResult.type;\n    s2Text = s2TypeResult.remaining;\n  }\n\n  const s2SuffixResult = parseDirectional(s2Text);\n  if (s2SuffixResult.direction) {\n    result.suffix2 = s2SuffixResult.direction;\n    s2Text = s2SuffixResult.remaining;\n  }\n\n  // Remaining text could be street name and/or city\n  const s2Parts = s2Text.split(/\\s+/).filter(Boolean);\n  if (s2Parts.length > 0) {\n    if (s2Parts.length === 1) {\n      result.street2 = s2Parts[0];\n    } else {\n      // Assume last word is city if we don't have state/zip to help determine\n      if (!result.state && !result.zip) {\n        result.street2 = s2Parts.slice(0, -1).join(' ');\n        result.city = s2Parts.slice(-1)[0];\n      } else {\n        result.street2 = s2Parts.join(' ');\n      }\n    }\n  }\n\n  // Return result if we have at least two streets\n  return (result.street1 && result.street2) ? result : null;\n}\n\n/**\n * Parse an informal address (more lenient parsing)\n */\nexport function parseInformalAddress(address: string, options: ParseOptions = {}): ParsedAddress | null {\n  // For informal addresses, be more lenient with parsing\n  const informalOptions: ParseOptions = {\n    ...options,\n    validatePostalCode: false, // Don't validate postal codes strictly\n    parseParenthetical: true,  // Always parse parenthetical info\n    extractFacilities: true,   // Always extract facilities\n  };\n\n  return parseLocation(address, informalOptions);\n}\n\n/**\n * Main parse function (alias for parseLocation for API compatibility)\n */\nexport function parseAddress(address: string, options: ParseOptions = {}): ParsedAddress | null {\n  return parseLocation(address, options);\n}\n\n/**\n * Create the parser object with all methods\n */\nexport const addressParser: AddressParser = {\n  parseLocation,\n  parseIntersection,\n  parseInformalAddress,\n  parseAddress,\n};","/**\n * address-plus - A modern, TypeScript-first address parser and normalizer\n * API-compatible with parse-address for seamless upgrades\n */\n\nimport type { AddressParser } from './types.js';\nimport { parseLocation, parseIntersection, parseInformalAddress, parseAddress } from './parser.js';\n\n// Export all types\nexport type * from './types.js';\n\n// Export parser functions\nexport { parseLocation, parseIntersection, parseInformalAddress, parseAddress };\n\n// Export data and utilities for advanced usage\nexport * from './data.js';\nexport * from './utils.js';\n\n/**\n * Default export for API compatibility with parse-address\n * Usage: import parser from 'address-plus';\n *        parser.parseLocation('123 Main St, New York, NY 10001')\n * \n * Or: import { parseLocation } from 'address-plus';\n */\nconst parser: AddressParser = {\n  parseLocation,\n  parseIntersection, \n  parseInformalAddress,\n  parseAddress,\n};\n\nexport default parser;"],"mappings":"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","names":[]}