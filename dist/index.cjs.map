{"version":3,"sources":["../src/index.ts","../src/data/ca-provinces.ts","../src/data/ca-street-types.ts","../src/data/directionals.ts","../src/data/facility-patterns.ts","../src/data/postal-patterns.ts","../src/data/address-patterns.ts","../src/data/secondary-unit-types.ts","../src/data/us-states.ts","../src/data/us-street-types.ts","../src/data/street-type-proper-case.ts","../src/utils/normalize-region.ts","../src/data/regions.ts","../src/utils/parsing.ts","../src/parser.ts"],"sourcesContent":["/**\n * address-plus - A modern, TypeScript-first address parser and normalizer\n * API-compatible with parse-address for seamless upgrades\n */\n\nimport type { AddressParser } from \"./types\";\nimport { parseAddress, parseInformalAddress, parseIntersection, parseLocation } from \"./parser\";\n\n/**\n * Default export for API compatibility with parse-address\n * Usage: import parser from 'address-plus';\n *        parser.parseLocation('123 Main St, New York, NY 10001')\n * \n * Or: import { parseLocation } from 'address-plus';\n */\nconst parser: AddressParser = {\n  parseLocation,\n  parseIntersection, \n  parseInformalAddress,\n  parseAddress,\n};\n\n// Export all types\nexport type * from \"./types\";\n\n// Export parser functions\nexport { parseAddress, parseInformalAddress, parseIntersection, parseLocation };\n\n// Export data and utilities for advanced usage\nexport * from \"./data\";\nexport * from \"./utils\";\n\nexport default parser;","import type { Region } from \"../types/region.js\";\n\n/**\n * Canadian provinces and territories mapping\n */\n\n/**\n * Official Canadian province and territory names in English mapped to their abbreviations\n */\nconst CA_PROVINCE_NAMES_EN: Record<string, string> = {\n  alberta: \"AB\",\n  \"british columbia\": \"BC\",\n  manitoba: \"MB\",\n  \"new brunswick\": \"NB\",\n  \"newfoundland and labrador\": \"NL\",\n  \"northwest territories\": \"NT\",\n  \"nova scotia\": \"NS\",\n  nunavut: \"NU\",\n  ontario: \"ON\",\n  \"prince edward island\": \"PE\",\n  quebec: \"QC\",\n  saskatchewan: \"SK\",\n  yukon: \"YT\",\n};\n\n/**\n * Official Canadian province and territory names in French mapped to their abbreviations\n */\nconst CA_PROVINCE_NAMES_FR: Record<string, string> = {\n  alberta: \"AB\",                          // Same in French\n  \"colombie-britannique\": \"BC\",\n  manitoba: \"MB\",                         // Same in French\n  \"nouveau-brunswick\": \"NB\",\n  \"terre-neuve-et-labrador\": \"NL\",\n  \"territoires du nord-ouest\": \"NT\",\n  \"nouvelle-écosse\": \"NS\",\n  nunavut: \"NU\",                          // Same in French (Inuktitut origin)\n  ontario: \"ON\",                          // Same in French\n  \"île-du-prince-édouard\": \"PE\",\n  québec: \"QC\",\n  saskatchewan: \"SK\",                     // Same in French (Cree origin)\n  yukon: \"YT\",                            // Same in French\n};\n\n/**\n * Combined official Canadian province and territory names (English and French)\n */\nconst CA_PROVINCE_NAMES: Record<string, string> = {\n  ...CA_PROVINCE_NAMES_EN,\n  ...CA_PROVINCE_NAMES_FR,\n};\n\n/**\n * Common shortened forms, abbreviations, and alternative names for Canadian provinces\n */\nconst CA_PROVINCE_ALTERNATIVES: Record<string, string> = {\n  // Alberta\n  alb: \"AB\",\n  alta: \"AB\",\n  \n  // Manitoba  \n  man: \"MB\",\n  \n  // Newfoundland and Labrador\n  newfoundland: \"NL\",\n  labrador: \"NL\",\n  \"terre-neuve\": \"NL\",\n  \"terre neuve\": \"NL\",\n  \"terre neuve et labrador\": \"NL\",\n  tnl: \"NL\",\n  \n  // Northwest Territories\n  northwest: \"NT\",\n  territories: \"NT\",\n  territoires: \"NT\",\n  nwt: \"NT\",\n  \"tn-o\": \"NT\",\n  \n  // Nunavut\n  nvt: \"NU\",\n  \n  // Ontario\n  ont: \"ON\",\n  \n  // Prince Edward Island\n  pei: \"PE\",\n  \"prince edward\": \"PE\",\n  \"ile-du-prince-édouard\": \"PE\",  // without circumflex\n  \"île du prince édouard\": \"PE\",   // without hyphens\n  \"ile du prince édouard\": \"PE\",   // without circumflex or hyphens\n  \"îpé\": \"PE\",\n  \n  // Saskatchewan\n  sask: \"SK\",\n};\n\n/**\n * Combined mapping of all Canadian province names and alternatives to their abbreviations\n */\nconst CA_PROVINCES: Record<string, string> = {\n  ...CA_PROVINCE_NAMES,\n  ...CA_PROVINCE_ALTERNATIVES,\n};\n\n/**\n * Array of Canadian provinces and territories as Region objects for fuzzy matching\n */\nconst CA_REGIONS: Region[] = Object.entries(CA_PROVINCES).map(([name, abbr]) => ({\n  abbr,\n  country: \"CA\",\n  name,\n}));\n\nexport { \n  CA_PROVINCES, \n  CA_REGIONS, \n  CA_PROVINCE_NAMES, \n  CA_PROVINCE_NAMES_EN, \n  CA_PROVINCE_NAMES_FR, \n  CA_PROVINCE_ALTERNATIVES \n};","/**\n * Canadian Street Types (Canada Post official abbreviations) - bilingual\n */\n\n/**\n * Mapping of Canadian street types and their variations to official Canada Post abbreviations\n * Includes both English and French terms\n */\nconst CA_STREET_TYPES: Record<string, string> = {\n  // English\n  autoroute: \"aut\",\n  av: \"ave\",\n  avenue: \"ave\",\n  blvd: \"blvd\",\n  boul: \"blvd\",\n  boulevard: \"blvd\",\n  carref: \"carref\",\n  carrefour: \"carref\",\n  cercle: \"cir\",\n  ch: \"ch\",\n  chemin: \"ch\",\n  cir: \"cir\",\n  circ: \"cir\",\n  circle: \"cir\",\n  cour: \"cour\",\n  court: \"crt\",\n  côte: \"côte\",\n  cres: \"cres\",\n  crescent: \"cres\",\n  crois: \"crois\",\n  croissant: \"crois\",\n  crt: \"crt\",\n  ct: \"crt\",\n  dr: \"dr\",\n  drive: \"dr\",\n  expy: \"expy\",\n  expressway: \"expy\",\n  freeway: \"fwy\",\n  fwy: \"fwy\",\n  gardens: \"gdns\",\n  gate: \"gate\",\n  gdns: \"gdns\",\n  grove: \"grove\",\n  heights: \"hts\",\n  hill: \"hill\",\n  highway: \"hwy\",\n  hts: \"hts\",\n  hwy: \"hwy\",\n  imp: \"imp\",\n  impasse: \"imp\",\n  lane: \"lane\",\n  mtée: \"mtée\",\n  montée: \"mtée\",\n  park: \"pk\",\n  parkway: \"pky\",\n  pass: \"pass\",\n  passage: \"pass\",\n  pk: \"pk\",\n  pky: \"pky\",\n  pl: \"pl\",\n  place: \"pl\",\n  plaza: \"plaza\",\n  point: \"pt\",\n  prom: \"prom\",\n  promenade: \"prom\",\n  pt: \"pt\",\n  rang: \"rang\",\n  rd: \"rd\",\n  rle: \"rle\",\n  road: \"rd\",\n  route: \"rte\",\n  rte: \"rte\",\n  rue: \"rue\",\n  ruelle: \"rle\",\n  sent: \"sent\",\n  sentier: \"sent\",\n  sq: \"sq\",\n  square: \"sq\",\n  st: \"st\",\n  street: \"st\",\n  terr: \"terr\",\n  terrace: \"terr\",\n  terrasse: \"terr\",\n  trail: \"trail\",\n  voie: \"voie\",\n  way: \"way\",\n};\n\nexport { CA_STREET_TYPES };","/**\n * Directional abbreviations for US and Canadian addresses\n */\n\n/**\n * Mapping of directional words to their standard abbreviations\n * Supports both English and French (for Canada)\n */\nconst DIRECTIONAL_MAP: Record<string, string> = {\n  // English\n  east: \"E\",\n  north: \"N\",\n  northeast: \"NE\",\n  northwest: \"NW\",\n  south: \"S\",\n  southeast: \"SE\",\n  southwest: \"SW\",\n  west: \"W\",\n  // Short forms\n  e: \"E\",\n  n: \"N\",\n  ne: \"NE\",\n  nw: \"NW\",\n  s: \"S\",\n  se: \"SE\",\n  sw: \"SW\",\n  w: \"W\",\n  // French (for Canada)\n  est: \"E\",\n  nord: \"N\",\n  \"nord-est\": \"NE\",\n  \"nord-ouest\": \"NW\",\n  ouest: \"W\",\n  sud: \"S\",\n  \"sud-est\": \"SE\",\n  \"sud-ouest\": \"SW\",\n};\n\nexport { DIRECTIONAL_MAP };","/**\n * Facility name recognition patterns\n */\n\n/**\n * Common facility name patterns for extraction\n */\nconst FACILITY_PATTERNS = [\n  /\\b(hospital|medical center|clinic|mall|shopping center|plaza|tower|building|center|centre)\\b/i,\n  /\\b(school|university|college|library|church|temple|mosque|synagogue)\\b/i,\n  /\\b(airport|station|terminal|depot|port|harbor|harbour)\\b/i,\n  /\\b(park|recreation|rec center|community center|civic center)\\b/i,\n];\n\nexport { FACILITY_PATTERNS };","/**\n * Regular expressions for postal code patterns\n */\n\n/**\n * Pattern for US ZIP codes (5 digits, optionally followed by +4)\n */\nconst ZIP_CODE_PATTERN = /^(\\d{5})(?:[-\\s]?(\\d{4}))?$/;\n\n/**\n * Pattern for Canadian postal codes (A1A 1A1 format)\n */\nconst CANADIAN_POSTAL_CODE_PATTERN = /^([A-Za-z]\\d[A-Za-z])\\s?(\\d[A-Za-z]\\d)$/;\n\nexport { CANADIAN_POSTAL_CODE_PATTERN, ZIP_CODE_PATTERN };","/**\n * Regular expression patterns for address parsing\n */\n\n/**\n * Pattern for secondary unit types and numbers\n * Matches: \"apt 123\", \"suite 5A\", \"unit 12\", \"#45\", \"# 45\", etc.\n */\nexport const SECONDARY_UNIT_PATTERN = /^(.*?)\\s+((?:suite|ste|apt|apartment|unit)\\s+[a-z0-9-]+|#\\s*[a-z0-9-]+)\\s*$/i;\n\n/**\n * Pattern for extracting unit type and number\n * Used to parse the secondary unit match\n */\nexport const UNIT_TYPE_NUMBER_PATTERN = /(suite|ste|apt|apartment|unit)\\s+([a-z0-9-]+)|#\\s*([a-z0-9-]+)/i;\n\n/**\n * Pattern for Canadian postal codes (more liberal matching)\n * Matches formats like: A1A 1A1, A1A1A1, a1a 1a1, etc.\n */\nexport const CANADIAN_POSTAL_LIBERAL_PATTERN = /([A-Z]\\d[A-Z]\\s*\\d[A-Z]\\d)/i;\n\n/**\n * Pattern for extracting parenthetical information\n * Matches content within parentheses\n */\nexport const PARENTHETICAL_PATTERN = /\\(([^)]+)\\)/g;","/**\n * Secondary unit types and abbreviations\n */\n\n/**\n * Mapping of secondary unit types to their standard abbreviations\n */\nconst SECONDARY_UNIT_TYPES: Record<string, string> = {\n  apartment: \"apt\",\n  apartme: \"apt\",\n  apt: \"apt\",\n  basement: \"bsmt\",\n  bld: \"bldg\",\n  bldg: \"bldg\",\n  bsmt: \"bsmt\",\n  building: \"bldg\",\n  department: \"dept\",\n  dept: \"dept\",\n  fl: \"fl\",\n  floor: \"fl\",\n  flr: \"fl\",\n  front: \"frnt\",\n  frnt: \"frnt\",\n  hanger: \"hngr\",\n  hngr: \"hngr\",\n  key: \"key\",\n  lbby: \"lbby\",\n  lobby: \"lbby\",\n  lot: \"lot\",\n  lower: \"lowr\",\n  lowr: \"lowr\",\n  ofc: \"ofc\",\n  office: \"ofc\",\n  penthouse: \"ph\",\n  ph: \"ph\",\n  pier: \"pier\",\n  rear: \"rear\",\n  rm: \"rm\",\n  room: \"rm\",\n  side: \"side\",\n  slip: \"slip\",\n  space: \"spc\",\n  spc: \"spc\",\n  ste: \"ste\",\n  stop: \"stop\",\n  su: \"ste\",\n  suite: \"ste\",\n  trailer: \"trlr\",\n  trlr: \"trlr\",\n  unit: \"unit\",\n  upper: \"uppr\",\n  uppr: \"uppr\",\n};\n\nexport { SECONDARY_UNIT_TYPES };","import type { Region } from \"../types/region.js\";\n\n/**\n * US States and territories mapping\n */\n\n/**\n * Official US state and territory names mapped to their abbreviations\n */\nconst US_STATE_NAMES: Record<string, string> = {\n  alabama: \"AL\",\n  alaska: \"AK\",\n  \"american samoa\": \"AS\",\n  arizona: \"AZ\",\n  arkansas: \"AR\",\n  california: \"CA\",\n  colorado: \"CO\",\n  connecticut: \"CT\",\n  delaware: \"DE\",\n  \"district of columbia\": \"DC\",\n  florida: \"FL\",\n  georgia: \"GA\",\n  guam: \"GU\",\n  hawaii: \"HI\",\n  idaho: \"ID\",\n  illinois: \"IL\",\n  indiana: \"IN\",\n  iowa: \"IA\",\n  kansas: \"KS\",\n  kentucky: \"KY\",\n  louisiana: \"LA\",\n  maine: \"ME\",\n  maryland: \"MD\",\n  massachusetts: \"MA\",\n  michigan: \"MI\",\n  minnesota: \"MN\",\n  mississippi: \"MS\",\n  missouri: \"MO\",\n  montana: \"MT\",\n  nebraska: \"NE\",\n  nevada: \"NV\",\n  \"new hampshire\": \"NH\",\n  \"new jersey\": \"NJ\",\n  \"new mexico\": \"NM\",\n  \"new york\": \"NY\",\n  \"north carolina\": \"NC\",\n  \"north dakota\": \"ND\",\n  \"northern mariana islands\": \"MP\",\n  ohio: \"OH\",\n  oklahoma: \"OK\",\n  oregon: \"OR\",\n  pennsylvania: \"PA\",\n  \"puerto rico\": \"PR\",\n  \"rhode island\": \"RI\",\n  \"south carolina\": \"SC\",\n  \"south dakota\": \"SD\",\n  tennessee: \"TN\",\n  texas: \"TX\",\n  utah: \"UT\",\n  vermont: \"VT\",\n  \"virgin islands\": \"VI\",\n  virginia: \"VA\",\n  washington: \"WA\",\n  \"west virginia\": \"WV\",\n  wisconsin: \"WI\",\n  wyoming: \"WY\",\n};\n\n/**\n * Common shortened forms, abbreviations, and alternative names for US states\n */\nconst US_STATE_ALTERNATIVES: Record<string, string> = {\n  // Alabama\n  ala: \"AL\",\n  bama: \"AL\",\n  \n  // Arizona\n  ariz: \"AZ\",\n  \n  // Arkansas\n  ark: \"AR\",\n  \n  // California\n  cal: \"CA\",\n  cali: \"CA\",\n  calif: \"CA\",\n  \n  // Colorado\n  colo: \"CO\",\n  \n  // Connecticut\n  conn: \"CT\",\n  \n  // Delaware\n  del: \"DE\",\n  \n  // District of Columbia\n  dc: \"DC\",\n  \n  // Florida\n  fla: \"FL\",\n  \n  // Illinois\n  ill: \"IL\",\n  \n  // Indiana\n  ind: \"IN\",\n  \n  // Kansas\n  kan: \"KS\",\n  kans: \"KS\",\n  \n  // Kentucky\n  ky: \"KY\",\n  kent: \"KY\",\n  \n  // Louisiana\n  la: \"LA\",\n  lou: \"LA\",\n  \n  // Massachusetts\n  mass: \"MA\",\n  \n  // Michigan\n  mich: \"MI\",\n  \n  // Minnesota\n  minn: \"MN\",\n  \n  // Mississippi\n  miss: \"MS\",\n  \n  // Missouri\n  mo: \"MO\",\n  \n  // Montana\n  mont: \"MT\",\n  \n  // Nebraska\n  neb: \"NE\",\n  nebr: \"NE\",\n  \n  // Nevada\n  nev: \"NV\",\n  \n  // New Hampshire\n  \"new hamp\": \"NH\",\n  \"new hampsh\": \"NH\",\n  \n  // New Jersey\n  \"new jers\": \"NJ\",\n  \n  // New Mexico\n  \"new mex\": \"NM\",\n  \"new mexic\": \"NM\",\n  \n  // North Carolina\n  \"n carolina\": \"NC\",\n  \"north car\": \"NC\",\n  \n  // North Dakota\n  \"n dakota\": \"ND\",\n  \"north dak\": \"ND\",\n  \n  // Oklahoma\n  okla: \"OK\",\n  \n  // Oregon\n  ore: \"OR\",\n  oreg: \"OR\",\n  \n  // Pennsylvania\n  penn: \"PA\",\n  pa: \"PA\",\n  penna: \"PA\",\n  pennsyl: \"PA\",\n  \n  // Rhode Island\n  \"rhode isl\": \"RI\",\n  \n  // South Carolina\n  \"s carolina\": \"SC\",\n  \"south car\": \"SC\",\n  \n  // South Dakota\n  \"s dakota\": \"SD\",\n  \"south dak\": \"SD\",\n  \n  // Tennessee\n  tenn: \"TN\",\n  \n  // Texas\n  tex: \"TX\",\n  \n  // Vermont\n  vt: \"VT\",\n  \n  // Virginia\n  va: \"VA\",\n  virg: \"VA\",\n  \n  // Washington\n  wash: \"WA\",\n  \n  // West Virginia\n  \"west va\": \"WV\",\n  \"west virg\": \"WV\",\n  \n  // Wisconsin\n  wis: \"WI\",\n  wisc: \"WI\",\n  \n  // Wyoming\n  wyo: \"WY\",\n};\n\n/**\n * Combined mapping of all US state names and alternatives to their abbreviations\n */\nconst US_STATES: Record<string, string> = {\n  ...US_STATE_NAMES,\n  ...US_STATE_ALTERNATIVES,\n};\n\n/**\n * Array of US states and territories as Region objects for fuzzy matching\n */\nconst US_REGIONS: Region[] = Object.entries(US_STATES).map(([name, abbr]) => ({\n  abbr,\n  country: \"US\",\n  name,\n}));\n\nexport { US_REGIONS, US_STATES, US_STATE_NAMES, US_STATE_ALTERNATIVES };","/**\n * US Street Types (USPS official abbreviations)\n */\n\n/**\n * Mapping of US street types and their variations to official USPS abbreviations\n */\nconst US_STREET_TYPES: Record<string, string> = {\n  allee: \"aly\",\n  alley: \"aly\",\n  ally: \"aly\",\n  anex: \"anx\",\n  annex: \"anx\",\n  annx: \"anx\",\n  arcade: \"arc\",\n  av: \"ave\",\n  ave: \"ave\",\n  aven: \"ave\",\n  avenu: \"ave\",\n  avenue: \"ave\",\n  avn: \"ave\",\n  avnue: \"ave\",\n  bayoo: \"byu\",\n  bayou: \"byu\",\n  beach: \"bch\",\n  bend: \"bnd\",\n  blf: \"blf\",\n  bluf: \"blf\",\n  bluff: \"blf\",\n  bluffs: \"blfs\",\n  bot: \"btm\",\n  bottom: \"btm\",\n  bottm: \"btm\",\n  boul: \"blvd\",\n  boulevard: \"blvd\",\n  boulv: \"blvd\",\n  branch: \"br\",\n  brdge: \"brg\",\n  bridge: \"brg\",\n  brnch: \"br\",\n  brook: \"brk\",\n  brooks: \"brks\",\n  burg: \"bg\",\n  burgs: \"bgs\",\n  byp: \"byp\",\n  bypa: \"byp\",\n  bypas: \"byp\",\n  bypass: \"byp\",\n  byps: \"byp\",\n  camp: \"cp\",\n  canyn: \"cyn\",\n  canyon: \"cyn\",\n  cape: \"cpe\",\n  causeway: \"cswy\",\n  causwa: \"cswy\",\n  cent: \"ctr\",\n  center: \"ctr\",\n  centr: \"ctr\",\n  centre: \"ctr\",\n  centers: \"ctrs\",\n  cir: \"cir\",\n  circ: \"cir\",\n  circl: \"cir\",\n  circle: \"cir\",\n  circles: \"cirs\",\n  cliff: \"clf\",\n  cliffs: \"clfs\",\n  club: \"clb\",\n  cmp: \"cp\",\n  cnter: \"ctr\",\n  cntr: \"ctr\",\n  cnyn: \"cyn\",\n  cmn: \"cmn\",\n  cmns: \"cmns\",\n  common: \"cmn\",\n  commons: \"cmns\",\n  cor: \"cor\",\n  corner: \"cor\",\n  corners: \"cors\",\n  cors: \"cors\",\n  course: \"crse\",\n  court: \"ct\",\n  courts: \"cts\",\n  cove: \"cv\",\n  coves: \"cvs\",\n  crcl: \"cir\",\n  crcle: \"cir\",\n  creek: \"crk\",\n  cres: \"cres\",\n  crescent: \"cres\",\n  crest: \"crst\",\n  crossing: \"xing\",\n  crossroad: \"xrd\",\n  crossroads: \"xrds\",\n  crsent: \"cres\",\n  crsnt: \"cres\",\n  crssing: \"xing\",\n  crssng: \"xing\",\n  crt: \"ct\",\n  curve: \"curv\",\n  dale: \"dl\",\n  dam: \"dm\",\n  div: \"dv\",\n  divide: \"dv\",\n  dr: \"dr\",\n  driv: \"dr\",\n  drive: \"dr\",\n  drives: \"drs\",\n  drv: \"dr\",\n  dvd: \"dv\",\n  est: \"est\",\n  estate: \"est\",\n  estates: \"ests\",\n  exp: \"expy\",\n  expr: \"expy\",\n  express: \"expy\",\n  expressway: \"expy\",\n  expw: \"expy\",\n  expy: \"expy\",\n  ext: \"ext\",\n  extension: \"ext\",\n  extensions: \"exts\",\n  extn: \"ext\",\n  extnsn: \"ext\",\n  fall: \"fall\",\n  falls: \"fls\",\n  ferry: \"fry\",\n  field: \"fld\",\n  fields: \"flds\",\n  flat: \"flt\",\n  flats: \"flts\",\n  fls: \"fls\",\n  ford: \"frd\",\n  fords: \"frds\",\n  forg: \"frg\",\n  forge: \"frg\",\n  forges: \"frgs\",\n  fork: \"frk\",\n  forks: \"frks\",\n  forest: \"frst\",\n  forests: \"frst\",\n  fort: \"ft\",\n  frd: \"frd\",\n  frds: \"frds\",\n  freewy: \"fwy\",\n  freeway: \"fwy\",\n  frg: \"frg\",\n  frgs: \"frgs\",\n  frk: \"frk\",\n  frks: \"frks\",\n  frry: \"fry\",\n  frst: \"frst\",\n  frt: \"ft\",\n  frway: \"fwy\",\n  frwy: \"fwy\",\n  fry: \"fry\",\n  ft: \"ft\",\n  fwy: \"fwy\",\n  garden: \"gdn\",\n  gardens: \"gdns\",\n  gardn: \"gdn\",\n  gatewy: \"gtwy\",\n  gateway: \"gtwy\",\n  gatway: \"gtwy\",\n  gdn: \"gdn\",\n  gdns: \"gdns\",\n  glen: \"gln\",\n  glens: \"glns\",\n  grden: \"gdn\",\n  grdn: \"gdn\",\n  grdns: \"gdns\",\n  green: \"grn\",\n  greens: \"grns\",\n  grov: \"grv\",\n  grove: \"grv\",\n  groves: \"grvs\",\n  gtway: \"gtwy\",\n  gtwy: \"gtwy\",\n  harb: \"hbr\",\n  harbor: \"hbr\",\n  harbors: \"hbrs\",\n  harbr: \"hbr\",\n  haven: \"hvn\",\n  hbr: \"hbr\",\n  hbrs: \"hbrs\",\n  height: \"hts\",\n  heights: \"hts\",\n  hgts: \"hts\",\n  highway: \"hwy\",\n  highwy: \"hwy\",\n  hill: \"hl\",\n  hills: \"hls\",\n  hiway: \"hwy\",\n  hiwy: \"hwy\",\n  hl: \"hl\",\n  hllw: \"holw\",\n  hls: \"hls\",\n  hollow: \"holw\",\n  hollows: \"holw\",\n  holw: \"holw\",\n  holws: \"holw\",\n  hrbor: \"hbr\",\n  ht: \"hts\",\n  hts: \"hts\",\n  hvn: \"hvn\",\n  hway: \"hwy\",\n  hwy: \"hwy\",\n  inlet: \"inlt\",\n  inlt: \"inlt\",\n  is: \"is\",\n  island: \"is\",\n  islands: \"iss\",\n  isle: \"isle\",\n  isles: \"isle\",\n  islnd: \"is\",\n  islnds: \"iss\",\n  iss: \"iss\",\n  jct: \"jct\",\n  jction: \"jct\",\n  jctn: \"jct\",\n  jctns: \"jcts\",\n  jcts: \"jcts\",\n  junctn: \"jct\",\n  junction: \"jct\",\n  junctions: \"jcts\",\n  juncton: \"jct\",\n  key: \"ky\",\n  keys: \"kys\",\n  knl: \"knl\",\n  knol: \"knl\",\n  knoll: \"knl\",\n  knolls: \"knls\",\n  knols: \"knls\",\n  ky: \"ky\",\n  kys: \"kys\",\n  lake: \"lk\",\n  lakes: \"lks\",\n  land: \"land\",\n  landing: \"lndg\",\n  lane: \"ln\",\n  lanes: \"ln\",\n  ldg: \"ldg\",\n  ldge: \"ldg\",\n  lf: \"lf\",\n  lgt: \"lgt\",\n  lgts: \"lgts\",\n  light: \"lgt\",\n  lights: \"lgts\",\n  lk: \"lk\",\n  lks: \"lks\",\n  ln: \"ln\",\n  lndg: \"lndg\",\n  lndng: \"lndg\",\n  loaf: \"lf\",\n  lck: \"lck\",\n  lcks: \"lcks\",\n  lock: \"lck\",\n  locks: \"lcks\",\n  lodg: \"ldg\",\n  lodge: \"ldg\",\n  loop: \"loop\",\n  loops: \"loop\",\n  mall: \"mall\",\n  manr: \"mnr\",\n  manor: \"mnr\",\n  manors: \"mnrs\",\n  manrs: \"mnrs\",\n  mdw: \"mdw\",\n  mdws: \"mdws\",\n  meadow: \"mdw\",\n  meadows: \"mdws\",\n  medows: \"mdws\",\n  mews: \"mews\",\n  mill: \"ml\",\n  mills: \"mls\",\n  mission: \"msn\",\n  missn: \"msn\",\n  ml: \"ml\",\n  mls: \"mls\",\n  mnt: \"mt\",\n  mntain: \"mtn\",\n  mntn: \"mtn\",\n  mntns: \"mtns\",\n  mnr: \"mnr\",\n  mnrs: \"mnrs\",\n  motorway: \"mtwy\",\n  mount: \"mt\",\n  mountain: \"mtn\",\n  mountains: \"mtns\",\n  mountin: \"mtn\",\n  msn: \"msn\",\n  mssn: \"msn\",\n  mt: \"mt\",\n  mtin: \"mtn\",\n  mtn: \"mtn\",\n  mtns: \"mtns\",\n  mtwy: \"mtwy\",\n  nck: \"nck\",\n  neck: \"nck\",\n  opas: \"opas\",\n  orch: \"orch\",\n  orchard: \"orch\",\n  orchrd: \"orch\",\n  oval: \"oval\",\n  overpass: \"opas\",\n  park: \"park\",\n  parks: \"park\",\n  parkway: \"pkwy\",\n  parkways: \"pkwy\",\n  parkwy: \"pkwy\",\n  pass: \"pass\",\n  passage: \"psge\",\n  path: \"path\",\n  paths: \"path\",\n  pike: \"pike\",\n  pikes: \"pike\",\n  pine: \"pne\",\n  pines: \"pnes\",\n  pky: \"pkwy\",\n  pkway: \"pkwy\",\n  pkwy: \"pkwy\",\n  pkwys: \"pkwy\",\n  pl: \"pl\",\n  place: \"pl\",\n  plain: \"pln\",\n  plains: \"plns\",\n  plaza: \"plz\",\n  plc: \"pl\",\n  pln: \"pln\",\n  plns: \"plns\",\n  plz: \"plz\",\n  plza: \"plz\",\n  pne: \"pne\",\n  pnes: \"pnes\",\n  point: \"pt\",\n  points: \"pts\",\n  port: \"prt\",\n  ports: \"prts\",\n  pr: \"pr\",\n  prairie: \"pr\",\n  prarie: \"pr\",\n  prk: \"park\",\n  prr: \"pr\",\n  prt: \"prt\",\n  prts: \"prts\",\n  psge: \"psge\",\n  pt: \"pt\",\n  pts: \"pts\",\n  rad: \"radl\",\n  radial: \"radl\",\n  radl: \"radl\",\n  ramp: \"ramp\",\n  ranch: \"rnch\",\n  ranches: \"rnch\",\n  rapid: \"rpd\",\n  rapids: \"rpds\",\n  rd: \"rd\",\n  rdg: \"rdg\",\n  rdge: \"rdg\",\n  rdgs: \"rdgs\",\n  rds: \"rds\",\n  rest: \"rst\",\n  ridge: \"rdg\",\n  ridges: \"rdgs\",\n  riv: \"riv\",\n  river: \"riv\",\n  rivr: \"riv\",\n  rnch: \"rnch\",\n  rnchs: \"rnch\",\n  road: \"rd\",\n  roads: \"rds\",\n  route: \"rte\",\n  row: \"row\",\n  rpd: \"rpd\",\n  rpds: \"rpds\",\n  rst: \"rst\",\n  rte: \"rte\",\n  rue: \"rue\",\n  run: \"run\",\n  rvr: \"riv\",\n  shl: \"shl\",\n  shls: \"shls\",\n  shoal: \"shl\",\n  shoals: \"shls\",\n  shoar: \"shr\",\n  shoars: \"shrs\",\n  shore: \"shr\",\n  shores: \"shrs\",\n  shr: \"shr\",\n  shrs: \"shrs\",\n  skyway: \"skwy\",\n  skwy: \"skwy\",\n  spg: \"spg\",\n  spgs: \"spgs\",\n  spng: \"spg\",\n  spngs: \"spgs\",\n  spring: \"spg\",\n  springs: \"spgs\",\n  sprng: \"spg\",\n  sprngs: \"spgs\",\n  spur: \"spur\",\n  spurs: \"spur\",\n  sq: \"sq\",\n  sqr: \"sq\",\n  sqre: \"sq\",\n  sqrs: \"sqs\",\n  sqs: \"sqs\",\n  squ: \"sq\",\n  square: \"sq\",\n  squares: \"sqs\",\n  st: \"st\",\n  sta: \"sta\",\n  station: \"sta\",\n  statn: \"sta\",\n  stn: \"sta\",\n  str: \"st\",\n  stra: \"stra\",\n  strav: \"stra\",\n  straven: \"stra\",\n  stravenue: \"stra\",\n  stream: \"strm\",\n  streme: \"strm\",\n  street: \"st\",\n  streets: \"sts\",\n  strm: \"strm\",\n  strt: \"st\",\n  strvn: \"stra\",\n  strvnue: \"stra\",\n  sts: \"sts\",\n  sumit: \"smt\",\n  sumitt: \"smt\",\n  summit: \"smt\",\n  smt: \"smt\",\n  ter: \"ter\",\n  terr: \"ter\",\n  terrace: \"ter\",\n  throughway: \"trwy\",\n  tpke: \"tpke\",\n  trace: \"trce\",\n  traces: \"trce\",\n  track: \"trak\",\n  tracks: \"trak\",\n  trafficway: \"trfy\",\n  trail: \"trl\",\n  trailer: \"trlr\",\n  trails: \"trl\",\n  trak: \"trak\",\n  trce: \"trce\",\n  trfy: \"trfy\",\n  trk: \"trak\",\n  trks: \"trak\",\n  trl: \"trl\",\n  trlr: \"trlr\",\n  trlrs: \"trlr\",\n  trls: \"trl\",\n  trnpk: \"tpke\",\n  trwy: \"trwy\",\n  tunel: \"tunl\",\n  tunl: \"tunl\",\n  tunls: \"tunl\",\n  tunnel: \"tunl\",\n  tunnels: \"tunl\",\n  tunnl: \"tunl\",\n  turnpike: \"tpke\",\n  turnpk: \"tpke\",\n  un: \"un\",\n  underpass: \"upas\",\n  union: \"un\",\n  unions: \"uns\",\n  uns: \"uns\",\n  upas: \"upas\",\n  valley: \"vly\",\n  valleys: \"vlys\",\n  vally: \"vly\",\n  vdct: \"via\",\n  via: \"via\",\n  viadct: \"via\",\n  viaduct: \"via\",\n  view: \"vw\",\n  views: \"vws\",\n  vill: \"vlg\",\n  villag: \"vlg\",\n  village: \"vlg\",\n  villages: \"vlgs\",\n  villg: \"vlg\",\n  villiage: \"vlg\",\n  ville: \"vl\",\n  vis: \"vis\",\n  vist: \"vis\",\n  vista: \"vis\",\n  vl: \"vl\",\n  vlg: \"vlg\",\n  vlgs: \"vlgs\",\n  vlly: \"vly\",\n  vly: \"vly\",\n  vlys: \"vlys\",\n  vst: \"vis\",\n  vsta: \"vis\",\n  vw: \"vw\",\n  vws: \"vws\",\n  walk: \"walk\",\n  walks: \"walk\",\n  wall: \"wall\",\n  way: \"way\",\n  ways: \"ways\",\n  well: \"wl\",\n  wells: \"wls\",\n  wl: \"wl\",\n  wls: \"wls\",\n  wy: \"way\",\n  xing: \"xing\",\n  xrd: \"xrd\",\n  xrds: \"xrds\",\n};\n\nexport { US_STREET_TYPES };","/**\n * Street type proper case mapping (USPS standards)\n * Maps lowercase abbreviations to their proper case equivalents\n */\n\nexport const STREET_TYPE_PROPER_CASE: Record<string, string> = {\n  'ave': 'Ave',\n  'st': 'St', \n  'dr': 'Dr',\n  'blvd': 'Blvd',\n  'ct': 'Ct',\n  'pl': 'Pl',\n  'rd': 'Rd',\n  'ln': 'Ln',\n  'way': 'Way',\n  'pkwy': 'Pkwy',\n  'plz': 'Plz',\n  'cir': 'Cir',\n  'ter': 'Ter',\n  'ctr': 'Ctr',\n  'loop': 'Loop',\n  'park': 'Park',\n  'hwy': 'Hwy',\n  'expy': 'Expy',\n  'fwy': 'Fwy',\n  'trl': 'Trl',\n  'sq': 'Sq',\n  'aly': 'Aly',\n  'anx': 'Anx',\n  'arc': 'Arc',\n  'byu': 'Byu',\n  'bch': 'Bch',\n  'bnd': 'Bnd',\n  'blf': 'Blf',\n  'blfs': 'Blfs',\n  'btm': 'Btm',\n  'br': 'Br',\n  'brg': 'Brg',\n  'brk': 'Brk',\n  'brks': 'Brks',\n  'bg': 'Bg',\n  'bgs': 'Bgs',\n  'byp': 'Byp',\n  'cp': 'Cp',\n  'cyn': 'Cyn',\n  'cpe': 'Cpe',\n  'cswy': 'Cswy',\n  'ctrs': 'Ctrs',\n  'cirs': 'Cirs',\n  'clf': 'Clf',\n  'clfs': 'Clfs',\n  'clb': 'Clb',\n  'cmn': 'Cmn',\n  'cmns': 'Cmns',\n  'cor': 'Cor',\n  'cors': 'Cors',\n  'crse': 'Crse',\n  'cts': 'Cts',\n  'cv': 'Cv',\n  'cvs': 'Cvs',\n  'crk': 'Crk',\n  'cres': 'Cres',\n  'crst': 'Crst',\n  'xing': 'Xing',\n  'xrd': 'Xrd',\n  'xrds': 'Xrds',\n  'curv': 'Curv',\n  'dl': 'Dl',\n  'dm': 'Dm',\n  'dv': 'Dv',\n  'drs': 'Drs',\n  'est': 'Est',\n  'ests': 'Ests',\n  'ext': 'Ext',\n  'exts': 'Exts',\n  'fall': 'Fall',\n  'fls': 'Fls',\n  'fry': 'Fry',\n  'fld': 'Fld',\n  'flds': 'Flds',\n  'flt': 'Flt',\n  'flts': 'Flts',\n  'frd': 'Frd',\n  'frds': 'Frds',\n  'frst': 'Frst',\n  'frg': 'Frg',\n  'frgs': 'Frgs',\n  'frk': 'Frk',\n  'frks': 'Frks',\n  'ft': 'Ft',\n  'gdn': 'Gdn',\n  'gdns': 'Gdns',\n  'gtwy': 'Gtwy',\n  'gln': 'Gln',\n  'glns': 'Glns',\n  'grn': 'Grn',\n  'grns': 'Grns',\n  'grv': 'Grv',\n  'grvs': 'Grvs',\n  'hbr': 'Hbr',\n  'hbrs': 'Hbrs',\n  'hvn': 'Hvn',\n  'hts': 'Hts',\n  'hl': 'Hl',\n  'hls': 'Hls',\n  'holw': 'Holw',\n  'inlt': 'Inlt',\n  'is': 'Is',\n  'iss': 'Iss',\n  'isle': 'Isle',\n  'jct': 'Jct',\n  'jcts': 'Jcts',\n  'ky': 'Ky',\n  'kys': 'Kys',\n  'knl': 'Knl',\n  'knls': 'Knls',\n  'lk': 'Lk',\n  'lks': 'Lks',\n  'land': 'Land',\n  'lndg': 'Lndg',\n  'lgt': 'Lgt',\n  'lgts': 'Lgts',\n  'lf': 'Lf',\n  'lck': 'Lck',\n  'lcks': 'Lcks',\n  'ldg': 'Ldg',\n  'mall': 'Mall',\n  'mnr': 'Mnr',\n  'mnrs': 'Mnrs',\n  'mdw': 'Mdw',\n  'mdws': 'Mdws',\n  'mews': 'Mews',\n  'ml': 'Ml',\n  'mls': 'Mls',\n  'msn': 'Msn',\n  'mtwy': 'Mtwy',\n  'mt': 'Mt',\n  'mtn': 'Mtn',\n  'mtns': 'Mtns',\n  'nck': 'Nck',\n  'orch': 'Orch',\n  'oval': 'Oval',\n  'opas': 'Opas',\n  'psge': 'Psge',\n  'path': 'Path',\n  'pike': 'Pike',\n  'pne': 'Pne',\n  'pnes': 'Pnes',\n  'pln': 'Pln',\n  'plns': 'Plns',\n  'pt': 'Pt',\n  'pts': 'Pts',\n  'prt': 'Prt',\n  'prts': 'Prts',\n  'pr': 'Pr',\n  'radl': 'Radl',\n  'ramp': 'Ramp',\n  'rnch': 'Rnch',\n  'rpd': 'Rpd',\n  'rpds': 'Rpds',\n  'rst': 'Rst',\n  'rdg': 'Rdg',\n  'rdgs': 'Rdgs',\n  'riv': 'Riv',\n  'rds': 'Rds',\n  'rte': 'Rte',\n  'row': 'Row',\n  'rue': 'Rue',\n  'run': 'Run',\n  'shl': 'Shl',\n  'shls': 'Shls',\n  'shr': 'Shr',\n  'shrs': 'Shrs',\n  'skwy': 'Skwy',\n  'spg': 'Spg',\n  'spgs': 'Spgs',\n  'spur': 'Spur',\n  'sqs': 'Sqs',\n  'sta': 'Sta',\n  'stra': 'Stra',\n  'strm': 'Strm',\n  'sts': 'Sts',\n  'smt': 'Smt',\n  'trce': 'Trce',\n  'trak': 'Trak',\n  'trfy': 'Trfy',\n  'trlr': 'Trlr',\n  'tunl': 'Tunl',\n  'tpke': 'Tpke',\n  'upas': 'Upas',\n  'un': 'Un',\n  'uns': 'Uns',\n  'vly': 'Vly',\n  'vlys': 'Vlys',\n  'via': 'Via',\n  'vw': 'Vw',\n  'vws': 'Vws',\n  'vlg': 'Vlg',\n  'vlgs': 'Vlgs',\n  'vl': 'Vl',\n  'vis': 'Vis',\n  'walk': 'Walk',\n  'ways': 'Ways',\n  'wall': 'Wall',\n  'wl': 'Wl',\n  'wls': 'Wls'\n};","import levenshtein from \"fast-levenshtein\";\n\nimport { REGIONS } from \"../data/regions.js\";\nimport type { Region } from \"../types/region.js\";\n\n/**\n * Region normalization utilities for fuzzy matching\n */\n\n/**\n * Normalizes a region input string to find the best matching state/province\n * Supports exact matches and fuzzy matching for misspellings\n * \n * @param input - The input string to normalize (state/province name or abbreviation)\n * @returns Object with abbreviation and country, or null if no match found\n * \n * @example\n * normalizeRegion('Calfornia'); // → { abbr: 'CA', country: 'US' }\n * normalizeRegion('Texes');     // → { abbr: 'TX', country: 'US' }\n * normalizeRegion('Ontaroi');   // → { abbr: 'ON', country: 'CA' }\n * normalizeRegion('qc');        // → { abbr: 'QC', country: 'CA' }\n * normalizeRegion('quebec');    // → { abbr: 'QC', country: 'CA' }\n */\nfunction normalizeRegion(input: string): { abbr: string; country: \"CA\" | \"US\" } | null {\n  if (!input) {\n    return null;\n  }\n\n  const clean = input.trim().replace(/\\./g, \"\").toLowerCase();\n  \n  // Return null for empty strings after trimming\n  if (clean === \"\") {\n    return null;\n  }\n\n  // 1. Exact match on abbreviation\n  const exactAbbr = REGIONS.find((r) => r.abbr.toLowerCase() === clean);\n  if (exactAbbr) {\n    return { abbr: exactAbbr.abbr, country: exactAbbr.country };\n  }\n\n  // 2. Exact match on full name\n  const exactName = REGIONS.find((r) => r.name.toLowerCase() === clean);\n  if (exactName) {\n    return { abbr: exactName.abbr, country: exactName.country };\n  }\n\n  // 3. Fuzzy match on name\n  let best: { region: Region; dist: number } | null = null;\n  for (const region of REGIONS) {\n    const dist = levenshtein.get(clean, region.name.toLowerCase());\n    if (!best || dist < best.dist) {\n      best = { region, dist };\n    }\n  }\n\n  // Accept if reasonably close (tune threshold)\n  // Additional check: for very short inputs (3 chars or less), require a closer match\n  // to avoid false positives with random strings\n  const threshold = clean.length <= 3 ? 1 : 3;\n  if (best && best.dist <= threshold) {\n    return { abbr: best.region.abbr, country: best.region.country };\n  }\n\n  return null;\n}\n\nexport { normalizeRegion };","import { CA_REGIONS } from \"./ca-provinces.js\";\nimport { US_REGIONS } from \"./us-states.js\";\n\n/**\n * Combined regions data for fuzzy matching\n */\n\n/**\n * Array containing all regions (US states/territories and Canadian provinces/territories)\n * for unified fuzzy matching across North America\n */\nconst REGIONS = [...US_REGIONS, ...CA_REGIONS];\n\nexport { REGIONS };","/**\n * Core parsing utilities and regex patterns\n */\n\nimport {\n  DIRECTIONAL_MAP,\n  US_STREET_TYPES,\n  CA_STREET_TYPES,\n  US_STATES,\n  CA_PROVINCES,\n  SECONDARY_UNIT_TYPES,\n  ZIP_CODE_PATTERN,\n  CANADIAN_POSTAL_CODE_PATTERN,\n  FACILITY_PATTERNS,\n} from '../data';\nimport { ParsedAddress, ParseOptions } from '../types';\n\n/**\n * Normalize text for consistent parsing\n */\nfunction normalizeText(text: string): string {\n  return text\n    .toLowerCase()\n    .replace(/\\s+/g, ' ')\n    .replace(/[.,;]/g, ' ')\n    .trim();\n}\n\n/**\n * Build regex patterns from dictionary\n */\nfunction buildRegexFromDict(dict: Record<string, string>, capture = true): RegExp {\n  const keys = Object.keys(dict).sort((a, b) => b.length - a.length);\n  const pattern = keys.map(key => key.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')).join('|');\n  return new RegExp(capture ? `\\\\b(${pattern})\\\\b` : `\\\\b(?:${pattern})\\\\b`, 'i');\n}\n\n/**\n * Extract and normalize directional\n */\nfunction parseDirectional(text: string): { direction: string | undefined; remaining: string } {\n  const dirPattern = buildRegexFromDict(DIRECTIONAL_MAP);\n  const match = text.match(dirPattern);\n  \n  if (match) {\n    const direction = DIRECTIONAL_MAP[match[1].toLowerCase()];\n    const remaining = text.replace(dirPattern, ' ').replace(/\\s+/g, ' ').trim();\n    return { direction, remaining };\n  }\n  \n  return { direction: undefined, remaining: text };\n}\n\n/**\n * Extract and normalize street type\n */\nfunction parseStreetType(text: string, country: 'US' | 'CA' = 'US'): { type: string | undefined; remaining: string } {\n  const typeMap = country === 'CA' ? { ...US_STREET_TYPES, ...CA_STREET_TYPES } : US_STREET_TYPES;\n  const typePattern = buildRegexFromDict(typeMap);\n  const match = text.match(typePattern);\n  \n  if (match) {\n    const type = typeMap[match[1].toLowerCase()];\n    const remaining = text.replace(typePattern, ' ').replace(/\\s+/g, ' ').trim();\n    return { type, remaining };\n  }\n  \n  return { type: undefined, remaining: text };\n}\n\n/**\n * Extract state or province  \n */\nfunction parseStateProvince(text: string, country?: 'US' | 'CA'): { state: string | undefined; remaining: string; detectedCountry?: 'US' | 'CA' } {\n  // Try US state abbreviations first (more specific than full names)\n  const usAbbrevPattern = new RegExp(`\\\\b(${Object.values(US_STATES).join('|')})\\\\b`, 'i');\n  let match = text.match(usAbbrevPattern);\n  if (match) {\n    const state = match[1].toUpperCase();\n    const remaining = text.replace(new RegExp(`\\\\b${match[1].replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'i'), ' ').replace(/\\s+/g, ' ').trim();\n    return { state, remaining, detectedCountry: 'US' };\n  }\n  \n  // Try Canadian province abbreviations\n  const caAbbrevPattern = new RegExp(`\\\\b(${Object.values(CA_PROVINCES).join('|')})\\\\b`, 'i');\n  match = text.match(caAbbrevPattern);\n  if (match) {\n    const state = match[1].toUpperCase();\n    const remaining = text.replace(new RegExp(`\\\\b${match[1].replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'i'), ' ').replace(/\\s+/g, ' ').trim();\n    return { state, remaining, detectedCountry: 'CA' };\n  }\n  \n  // Try US states full names (only if no abbreviation found)\n  const usPattern = buildRegexFromDict(US_STATES);\n  match = text.match(usPattern);\n  if (match) {\n    const state = US_STATES[match[1].toLowerCase()];\n    const remaining = text.replace(new RegExp(`\\\\b${match[1].replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'gi'), ' ').replace(/\\s+/g, ' ').trim();\n    return { state, remaining, detectedCountry: 'US' };\n  }\n  \n  // Try Canadian provinces full names\n  const caPattern = buildRegexFromDict(CA_PROVINCES);\n  match = text.match(caPattern);\n  if (match) {\n    const state = CA_PROVINCES[match[1].toLowerCase()];\n    const remaining = text.replace(new RegExp(`\\\\b${match[1].replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'gi'), ' ').replace(/\\s+/g, ' ').trim();\n    return { state, remaining, detectedCountry: 'CA' };\n  }\n  \n  return { state: undefined, remaining: text };\n}\n\n/**\n * Extract postal code (ZIP or Canadian postal code)\n */\nfunction parsePostalCode(text: string): { zip: string | undefined; zipext: string | undefined; remaining: string; detectedCountry?: 'US' | 'CA' } {\n  // Try US ZIP code - look for it anywhere in the text\n  const zipMatch = text.match(/\\b(\\d{5})(?:[-\\s]?(\\d{4}))?\\b/);\n  if (zipMatch) {\n    const zip = zipMatch[1];\n    const zipext = zipMatch[2];\n    const remaining = text.replace(zipMatch[0], ' ').replace(/\\s+/g, ' ').trim();\n    return { zip, zipext, remaining, detectedCountry: 'US' };\n  }\n  \n  // Try Canadian postal code - look for it anywhere in the text\n  const postalMatch = text.match(/\\b([A-Za-z]\\d[A-Za-z])\\s?(\\d[A-Za-z]\\d)\\b/);\n  if (postalMatch) {\n    const zip = `${postalMatch[1]} ${postalMatch[2]}`.toUpperCase();\n    const remaining = text.replace(postalMatch[0], ' ').replace(/\\s+/g, ' ').trim();\n    return { zip, zipext: undefined, remaining, detectedCountry: 'CA' };\n  }\n  \n  return { zip: undefined, zipext: undefined, remaining: text };\n}\n\n/**\n * Parse secondary unit information (apartment, suite, etc.)\n */\nfunction parseSecondaryUnit(text: string): { \n  unit: string | undefined; \n  sec_unit_type: string | undefined; \n  sec_unit_num: string | undefined; \n  remaining: string;\n} {\n  const unitPattern = buildRegexFromDict(SECONDARY_UNIT_TYPES);\n  \n  // Look for unit type followed by number\n  const unitMatch = text.match(new RegExp(`${unitPattern.source}\\\\s*(\\\\d+\\\\w*|[a-zA-Z]+\\\\d*)`));\n  if (unitMatch) {\n    const sec_unit_type = SECONDARY_UNIT_TYPES[unitMatch[1].toLowerCase()];\n    const sec_unit_num = unitMatch[2];\n    const unit = `${sec_unit_type} ${sec_unit_num}`;\n    const remaining = text.replace(unitMatch[0], ' ').replace(/\\s+/g, ' ').trim();\n    return { unit, sec_unit_type, sec_unit_num, remaining };\n  }\n  \n  // Look for just numbers that might be unit numbers\n  const numberMatch = text.match(/\\b(apt|apartment|unit|ste|suite|#)\\s*(\\d+\\w*)\\b/i);\n  if (numberMatch) {\n    const sec_unit_type = SECONDARY_UNIT_TYPES[numberMatch[1].toLowerCase()] || numberMatch[1].toLowerCase();\n    const sec_unit_num = numberMatch[2];\n    const unit = `${sec_unit_type} ${sec_unit_num}`;\n    const remaining = text.replace(numberMatch[0], ' ').replace(/\\s+/g, ' ').trim();\n    return { unit, sec_unit_type, sec_unit_num, remaining };\n  }\n  \n  return { unit: undefined, sec_unit_type: undefined, sec_unit_num: undefined, remaining: text };\n}\n\n/**\n * Extract facility names\n */\n/**\n * Parse facility information from address\n */\nfunction parseFacility(text: string): { facility: string | undefined; remaining: string } {\n  for (const pattern of FACILITY_PATTERNS) {\n    const match = text.match(pattern);\n    if (match) {\n      // Try to extract the full facility name (word before + match + word after if relevant)\n      const fullMatch = text.match(new RegExp(`\\\\b[\\\\w\\\\s]*${match[0]}[\\\\w\\\\s]*\\\\b`, 'i'));\n      if (fullMatch) {\n        const facility = fullMatch[0].trim();\n        const remaining = text.replace(fullMatch[0], ' ').replace(/\\s+/g, ' ').trim();\n        return { facility, remaining };\n      }\n    }\n  }\n  \n  return { facility: undefined, remaining: text };\n}\n\n/**\n * Parse parenthetical information\n */\nfunction parseParenthetical(text: string): { secondary: string | undefined; remaining: string } {\n  const parenMatch = text.match(/\\(([^)]+)\\)/);\n  if (parenMatch) {\n    const secondary = parenMatch[1].trim();\n    const remaining = text.replace(parenMatch[0], ' ').replace(/\\s+/g, ' ').trim();\n    return { secondary, remaining };\n  }\n  \n  return { secondary: undefined, remaining: text };\n}\n\n/**\n * Extract street number (including fractional)\n */\nfunction parseStreetNumber(text: string): { number: string | undefined; remaining: string } {\n  // Handle fractional numbers like \"123 1/2\" or \"123-1/2\"\n  const fracMatch = text.match(/^\\s*(\\d+(?:\\s*[-\\/]\\s*\\d+\\/\\d+|\\s+\\d+\\/\\d+)?)\\b/);\n  if (fracMatch) {\n    const number = fracMatch[1].replace(/\\s+/g, ' ').trim();\n    const remaining = text.replace(fracMatch[0], ' ').replace(/\\s+/g, ' ').trim();\n    return { number, remaining };\n  }\n  \n  // Handle simple numbers\n  const numMatch = text.match(/^\\s*(\\d+)\\b/);\n  if (numMatch) {\n    const number = numMatch[1];\n    const remaining = text.replace(numMatch[0], ' ').replace(/\\s+/g, ' ').trim();\n    return { number, remaining };\n  }\n  \n  return { number: undefined, remaining: text };\n}\n\n/**\n * Detect country from address components\n */\nfunction detectCountry(address: ParsedAddress): 'US' | 'CA' | undefined {\n  if (address.state) {\n    if (Object.values(US_STATES).includes(address.state) || Object.keys(US_STATES).includes(address.state.toLowerCase())) {\n      return 'US';\n    }\n    if (Object.values(CA_PROVINCES).includes(address.state) || Object.keys(CA_PROVINCES).includes(address.state.toLowerCase())) {\n      return 'CA';\n    }\n  }\n  \n  if (address.zip) {\n    if (ZIP_CODE_PATTERN.test(address.zip)) {\n      return 'US';\n    }\n    if (CANADIAN_POSTAL_CODE_PATTERN.test(address.zip)) {\n      return 'CA';\n    }\n  }\n  \n  return undefined;\n}\n\nexport {\n  buildRegexFromDict,\n  detectCountry,\n  normalizeText,\n  parseDirectional,\n  parseFacility,\n  parseParenthetical,\n  parsePostalCode,\n  parseSecondaryUnit,\n  parseStateProvince,\n  parseStreetNumber,\n  parseStreetType,\n};","/**\n * Main address parser implementation\n * Based on the original parse-address library patterns\n */\n\nimport type { AddressParser, ParsedAddress, ParsedIntersection, ParseOptions } from \"./types\";\nimport {\n  CA_PROVINCES,\n  CA_STREET_TYPES,\n  CANADIAN_POSTAL_LIBERAL_PATTERN,\n  DIRECTIONAL_MAP,\n  FACILITY_PATTERNS,\n  SECONDARY_UNIT_PATTERN,\n  SECONDARY_UNIT_TYPES,\n  STREET_TYPE_PROPER_CASE,\n  UNIT_TYPE_NUMBER_PATTERN,\n  US_STATES,\n  US_STREET_TYPES,\n} from \"./data\";\nimport {\n  detectCountry,\n  normalizeText,\n  parseDirectional,\n  parseFacility,\n  parseParenthetical,\n  parsePostalCode,\n  parseSecondaryUnit,\n  parseStateProvince,\n  parseStreetNumber,\n  parseStreetType,\n} from \"./utils\";\n\n// Build regex patterns similar to original parse-address\nconst buildPatterns = () => {\n  const streetTypes = Object.keys(US_STREET_TYPES).concat(Object.values(US_STREET_TYPES))\n    .concat(Object.keys(CA_STREET_TYPES)).concat(Object.values(CA_STREET_TYPES))\n    .filter((v, i, arr) => arr.indexOf(v) === i)\n    .sort((a, b) => b.length - a.length)\n    .join('|');\n  \n  const directionals = Object.keys(DIRECTIONAL_MAP).concat(Object.values(DIRECTIONAL_MAP))\n    .filter((v, i, arr) => arr.indexOf(v) === i)\n    .sort((a, b) => b.length - a.length)\n    .join('|');\n  \n  const states = Object.keys(US_STATES).concat(Object.values(US_STATES))\n    .concat(Object.keys(CA_PROVINCES)).concat(Object.values(CA_PROVINCES))\n    .filter((v, i, arr) => arr.indexOf(v) === i)\n    .join('|');\n  \n  // Create separate pattern for state abbreviations (2-3 chars) vs full names\n  const stateAbbrevs = Object.values(US_STATES).concat(Object.values(CA_PROVINCES))\n    .filter((v, i, arr) => arr.indexOf(v) === i && v.length <= 3)\n    .sort((a, b) => b.length - a.length)\n    .join('|');\n    \n  const stateFullNames = Object.keys(US_STATES).concat(Object.keys(CA_PROVINCES))\n    .filter((v, i, arr) => arr.indexOf(v) === i && v.length > 3)\n    .sort((a, b) => b.length - a.length)\n    .join('|');\n\n  return {\n    number: String.raw`(\\d+[-\\/]*\\d*|\\w\\d+\\w\\d+)`,  // Changed to not match directionals\n    fraction: String.raw`(\\d+\\/\\d+)`,\n    directional: `(${directionals})`,\n    streetType: `(${streetTypes})`,\n    state: `\\\\b(${states})\\\\b`,\n    stateAbbrev: `\\\\b(${stateAbbrevs})\\\\b`,\n    stateFullName: `\\\\b(${stateFullNames})\\\\b`,\n    zip: String.raw`(\\d{5}(?:[-\\s]\\d{4})?)`,\n    poBox: String.raw`(?:p\\.?o\\.?\\s*box|post\\s*office\\s*box|pobox)\\s*(\\d+)`,\n    intersection: String.raw`\\s+(?:and|&|at|\\@)\\s+`,\n    secUnit: String.raw`(?:(suite|ste|apt|apartment|unit|#)\\s+([a-z0-9-]+))`\n  };\n};\n\n/**\n * Parse a location string into address components\n */\nfunction parseLocation(address: string, options: ParseOptions = {}): ParsedAddress | null {\n  if (!address || typeof address !== 'string') {\n    return null;\n  }\n\n  const original = address.trim();\n\n  // Check for intersection first\n  const patterns = buildPatterns();\n  if (new RegExp(patterns.intersection, 'i').test(original)) {\n    return parseIntersection(original, options);\n  }\n\n  // Check for PO Box\n  const poBoxMatch = original.match(new RegExp(`^\\\\s*${patterns.poBox}`, 'i'));\n  if (poBoxMatch) {\n    return parsePoBox(original, options);\n  }\n\n  // Try standard address parsing\n  return parseStandardAddress(original, options) || parseInformalAddress(original, options);\n}\n\n/**\n * Parse PO Box addresses\n */\nfunction parsePoBox(address: string, options: ParseOptions = {}): ParsedAddress | null {\n  const patterns = buildPatterns();\n  const match = address.match(new RegExp(\n    `^\\\\s*${patterns.poBox}\\\\s*,?\\\\s*` +\n    `(?:([^\\\\d,]+?)\\\\s*,?\\\\s*)?` +  // city\n    `(?:(${patterns.state.slice(2, -2)})\\\\s*)?` +   // state\n    `(?:(${patterns.zip.slice(1, -1)}))?\\\\s*$`, 'i'\n  ));\n\n  if (!match) return null;\n\n  const result: ParsedAddress = {\n    sec_unit_type: normalizePoBoxType(match[1]),\n    sec_unit_num: match[2]\n  };\n\n  if (match[3]) result.city = match[3].trim();\n  if (match[4]) result.state = match[4].toUpperCase();\n  if (match[5]) result.zip = match[5];\n\n  // Detect country\n  result.country = detectCountry(result);\n\n  return result;\n}\n\n/**\n * Normalize PO Box type to standard format\n */\nfunction normalizePoBoxType(type: string): string {\n  const normalized = type.toLowerCase().replace(/\\./g, '').replace(/\\s+/g, ' ').trim();\n  if (normalized.includes('post office box') || normalized.includes('po box') || normalized.includes('pobox')) {\n    return 'PO box';\n  }\n  return normalized;\n}\n\n/**\n * Parse standard addresses with number, street, type, city, state, zip\n */\nfunction parseStandardAddress(address: string, options: ParseOptions = {}): ParsedAddress | null {\n  const patterns = buildPatterns();\n  \n  // Split by comma to handle comma-separated components\n  const commaParts = address.split(',').map(p => p.trim());\n  \n  // Extract ZIP from end and work backwards\n  let zipPart = '';\n  let statePart = '';\n  let cityPart = '';\n  let addressPart = commaParts[0];\n  \n  // Track which comma parts to exclude from city parsing (for secondary units, facilities)\n  const excludedPartIndices = new Set<number>();\n  \n  // Handle non-comma separated addresses\n  if (commaParts.length === 1) {\n    // No commas, try to parse city/state/zip from the end\n    let remainingText = address.trim();\n    \n    // Extract ZIP first\n    const zipMatch = remainingText.match(new RegExp(`\\\\s+(${patterns.zip.slice(1, -1)})\\\\s*$`));\n    const caPostalMatch = remainingText.match(new RegExp(`\\\\s+(${CANADIAN_POSTAL_LIBERAL_PATTERN.source})\\\\s*$`));\n    \n    if (zipMatch) {\n      zipPart = zipMatch[1];\n      remainingText = remainingText.replace(zipMatch[0], '').trim();\n    } else if (caPostalMatch) {\n      zipPart = caPostalMatch[1];\n      remainingText = remainingText.replace(caPostalMatch[0], '').trim();\n    }\n    \n    // Extract state (try abbreviations first, then full names)\n    const stateAbbrevMatch = remainingText.match(new RegExp(`\\\\s+(${patterns.stateAbbrev.slice(2, -2)})\\\\s*$`, 'i'));\n    const stateFullMatch = remainingText.match(new RegExp(`\\\\s+(${patterns.stateFullName.slice(2, -2)})\\\\s*$`, 'i'));\n    \n    if (stateAbbrevMatch) {\n      statePart = stateAbbrevMatch[1];\n      remainingText = remainingText.replace(stateAbbrevMatch[0], '').trim();\n    } else if (stateFullMatch) {\n      statePart = stateFullMatch[1];\n      remainingText = remainingText.replace(stateFullMatch[0], '').trim();\n    }\n\n    // Extract city (what's left after removing ZIP and state, taking the last word(s))\n    if (remainingText) {\n      // Look for city at the end of remaining text, but be smart about it\n      // If we have a state, we can be more confident about city extraction\n      // If no state, only extract city if we can clearly identify a non-street-type word\n      const hasState = !!statePart;\n      \n      if (hasState) {\n        // With state, we can confidently extract city as usual\n        const singleWordCityMatch = remainingText.match(/\\s+([A-Za-z]+)$/);\n        const twoWordCityMatch = remainingText.match(/\\s+([A-Za-z]+\\s+[A-Za-z]+)$/);\n        \n        let potentialCity = '';\n        let matchToReplace = null;\n        \n        // Prefer longer matches first (two words over one word)\n        if (twoWordCityMatch) {\n          potentialCity = twoWordCityMatch[1].trim();\n          matchToReplace = twoWordCityMatch[0];\n        } else if (singleWordCityMatch) {\n          potentialCity = singleWordCityMatch[1].trim();\n          matchToReplace = singleWordCityMatch[0];\n        }\n        \n        // Check if potential city is actually a street type or starts with a street type\n        const isStreetType = new RegExp(`^(${patterns.streetType.slice(1, -1)})$`, 'i').test(potentialCity);\n        const startsWithStreetTypeMatch = potentialCity.match(new RegExp(`^(${patterns.streetType.slice(1, -1)})\\\\s+(.+)$`, 'i'));\n        \n        if (potentialCity && !isStreetType && matchToReplace) {\n          if (startsWithStreetTypeMatch) {\n            // If the potential city starts with a street type, extract just the city part\n            cityPart = startsWithStreetTypeMatch[2];\n            // Only remove the city part, not the street type\n            const cityOnlyMatch = remainingText.match(new RegExp(`\\\\s+(${cityPart.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')})$`));\n            if (cityOnlyMatch) {\n              remainingText = remainingText.replace(cityOnlyMatch[0], '').trim();\n            }\n          } else {\n            cityPart = potentialCity;\n            remainingText = remainingText.replace(matchToReplace, '').trim();\n          }\n        }\n      } else {\n        // Without state, be very conservative about city extraction\n        // Only extract if we have a clear non-street-type word at the end\n        // AND the remaining text suggests a full address (at least 4+ words)\n        const wordCount = remainingText.split(/\\s+/).length;\n        if (wordCount >= 5) { // More conservative: at least \"number prefix street type city\"\n          const singleWordCityMatch = remainingText.match(/\\s+([A-Za-z]+)$/);\n          \n          if (singleWordCityMatch) {\n            const potentialCity = singleWordCityMatch[1].trim();\n            const isStreetType = new RegExp(`^(${patterns.streetType.slice(1, -1)})$`, 'i').test(potentialCity);\n            const isDirectional = new RegExp(`^(${patterns.directional.slice(1, -1)})$`, 'i').test(potentialCity);\n            \n            // Only extract if it's clearly not a street component\n            if (!isStreetType && !isDirectional && potentialCity.length > 2) {\n              cityPart = potentialCity;\n              remainingText = remainingText.replace(singleWordCityMatch[0], '').trim();\n            }\n          }\n        }\n      }\n    }\n    \n    // Use remaining text as address part (after removing city/state/zip)\n    if (remainingText) {\n      addressPart = remainingText;\n    }\n  } else {\n    const lastPart = commaParts[commaParts.length - 1];\n    const zipMatch = lastPart.match(new RegExp(`(${patterns.zip.slice(1, -1)})`));\n    const caPostalMatch = lastPart.match(CANADIAN_POSTAL_LIBERAL_PATTERN);\n    \n    if (zipMatch) {\n      zipPart = zipMatch[1];\n      // Remove ZIP from the part and see what's left (might be city + state)\n      const remainingAfterZip = lastPart.replace(zipMatch[0], '').trim();\n      if (remainingAfterZip) {\n        // Try to parse city and state from remaining text\n        const cityStateAbbrevMatch = remainingAfterZip.match(new RegExp(`^(.+?)\\\\s+(${patterns.stateAbbrev.slice(2, -2)})\\\\s*$`, 'i'));\n        if (cityStateAbbrevMatch) {\n          cityPart = cityStateAbbrevMatch[1].trim();\n          statePart = cityStateAbbrevMatch[2].trim();\n        } else {\n          const cityStateFullMatch = remainingAfterZip.match(new RegExp(`^(.+?)\\\\s+(${patterns.stateFullName.slice(2, -2)})\\\\s*$`, 'i'));\n          if (cityStateFullMatch) {\n            cityPart = cityStateFullMatch[1].trim();\n            statePart = cityStateFullMatch[2].trim();\n          } else {\n            // Just state or unknown format\n            statePart = remainingAfterZip;\n          }\n        }\n      }\n      // Check if we have city in previous part (but skip excluded parts like secondary units)\n      if (commaParts.length > 2) {\n        // Find the last non-excluded part that could be a city\n        for (let i = commaParts.length - 2; i >= 1; i--) {\n          if (!excludedPartIndices.has(i)) {\n            cityPart = commaParts[i].trim();\n            break;\n          }\n        }\n      } else if (commaParts.length === 2 && !statePart) {\n        // No ZIP was removed, so this might be city, state\n        const remainingText = lastPart.replace(zipMatch[0], '').trim();\n        const cityStateAbbrevMatch = remainingText.match(new RegExp(`^(.+?)\\\\s+(${patterns.stateAbbrev.slice(2, -2)})\\\\s*$`, 'i'));\n        if (cityStateAbbrevMatch) {\n          cityPart = cityStateAbbrevMatch[1].trim();\n          statePart = cityStateAbbrevMatch[2].trim();\n        } else {\n          const cityStateFullMatch = remainingText.match(new RegExp(`^(.+?)\\\\s+(${patterns.stateFullName.slice(2, -2)})\\\\s*$`, 'i'));\n          if (cityStateFullMatch) {\n            cityPart = cityStateFullMatch[1].trim();\n            statePart = cityStateFullMatch[2].trim();\n          } else {\n            cityPart = remainingText;\n          }\n        }\n      }\n    } else if (caPostalMatch) {\n      // Canadian postal code\n      zipPart = caPostalMatch[1];\n      const remainingAfterZip = lastPart.replace(caPostalMatch[0], '').trim();\n      if (remainingAfterZip) {\n        statePart = remainingAfterZip;\n      }\n      if (commaParts.length > 2) {\n        cityPart = commaParts[commaParts.length - 2].trim();\n      } else if (commaParts.length === 2) {\n        const cityStateText = lastPart.replace(caPostalMatch[0], '').trim();\n        const cityStateAbbrevMatch = cityStateText.match(new RegExp(`^(.+?)\\\\s+(${patterns.stateAbbrev.slice(2, -2)})\\\\s*$`, 'i'));\n        if (cityStateAbbrevMatch) {\n          cityPart = cityStateAbbrevMatch[1].trim();\n          statePart = cityStateAbbrevMatch[2].trim();\n        } else {\n          const cityStateFullMatch = cityStateText.match(new RegExp(`^(.+?)\\\\s+(${patterns.stateFullName.slice(2, -2)})\\\\s*$`, 'i'));\n          if (cityStateFullMatch) {\n            cityPart = cityStateFullMatch[1].trim();\n            statePart = cityStateFullMatch[2].trim();\n          } else {\n            cityPart = cityStateText;\n          }\n        }\n      }\n    } else {\n      // No ZIP found, try to parse city/state from remaining parts (excluding secondary units)\n      const nonExcludedParts = commaParts.slice(1).filter((part, index) => !excludedPartIndices.has(index + 1));\n      const cityStateText = nonExcludedParts.join(' ').trim();\n      \n      // First try to match with state abbreviations (more specific)\n      const cityStateAbbrevMatch = cityStateText.match(new RegExp(`^(.+?)\\\\s+(${patterns.stateAbbrev.slice(2, -2)})\\\\s*$`, 'i'));\n      if (cityStateAbbrevMatch) {\n        cityPart = cityStateAbbrevMatch[1].trim();\n        statePart = cityStateAbbrevMatch[2].trim();\n      } else {\n        // Then try full state names\n        const cityStateFullMatch = cityStateText.match(new RegExp(`^(.+?)\\\\s+(${patterns.stateFullName.slice(2, -2)})\\\\s*$`, 'i'));\n        if (cityStateFullMatch) {\n          cityPart = cityStateFullMatch[1].trim();\n          statePart = cityStateFullMatch[2].trim();\n        } else {\n          // Check if the entire text is just a state/province (abbreviation first)\n          const justStateAbbrevMatch = cityStateText.match(new RegExp(`^(${patterns.stateAbbrev.slice(2, -2)})\\\\s*$`, 'i'));\n          if (justStateAbbrevMatch) {\n            statePart = justStateAbbrevMatch[1].trim();\n          } else {\n            const justStateFullMatch = cityStateText.match(new RegExp(`^(${patterns.stateFullName.slice(2, -2)})\\\\s*$`, 'i'));\n            if (justStateFullMatch) {\n              statePart = justStateFullMatch[1].trim();\n            } else {\n              cityPart = cityStateText;\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  // Check for facility names and secondary units in middle comma parts\n  let facilityPart = '';\n  let secondaryUnitPart = '';\n  \n  if (commaParts.length > 2) {\n    // Check middle parts for facility patterns and secondary units\n    for (let i = 1; i < commaParts.length - 1; i++) {\n      const part = commaParts[i].trim();\n      \n      // Check for secondary units first (Suite 500, Apt 3B, #45, etc.)\n      const unitMatch = part.match(/^(?:suite|ste|apt|apartment|unit)\\s+[a-z0-9-]+$|^#\\s*[a-z0-9-]+$/i);\n      if (unitMatch && !secondaryUnitPart) {\n        secondaryUnitPart = part;\n        excludedPartIndices.add(i);\n        continue;\n      }\n      \n      // Check for facility patterns\n      for (const pattern of FACILITY_PATTERNS) {\n        if (pattern.test(part)) {\n          facilityPart = part;\n          excludedPartIndices.add(i);\n          break;\n        }\n      }\n    }\n  }\n  \n  const result: ParsedAddress = {};\n  \n  // Extract parenthetical information first\n  let secondaryInfo = '';\n  const parentheticalMatch = addressPart.match(/^(.*?)\\s*\\(([^)]+)\\)\\s*$/);\n  if (parentheticalMatch) {\n    addressPart = parentheticalMatch[1].trim();\n    secondaryInfo = parentheticalMatch[2].trim();\n  }\n  \n  // Parse address part using step-by-step approach\n  let remaining = addressPart.trim();\n  \n  // 0. Check for secondary unit at the beginning (e.g., \"#42 233 S Wacker Dr\")\n  const prefixSecUnitMatch = remaining.match(/^((?:suite|ste|apt|apartment|unit)\\s+[a-z0-9-]+|#\\s*[a-z0-9-]+)\\s+(.*)$/i);\n  if (prefixSecUnitMatch) {\n    const unitText = prefixSecUnitMatch[1];\n    remaining = prefixSecUnitMatch[2];\n    \n    // Parse the unit type and number\n    const unitParts = unitText.match(UNIT_TYPE_NUMBER_PATTERN);\n    if (unitParts) {\n      if (unitParts[1] && unitParts[2]) {\n        // Standard format: \"apt 123\", \"suite 5A\", etc.\n        const rawType = unitParts[1].toLowerCase();\n        result.sec_unit_type = SECONDARY_UNIT_TYPES[rawType] || rawType;\n        result.sec_unit_num = unitParts[2];\n      } else if (unitParts[3]) {\n        // Hash format: \"#123\", \"# 123\"\n        result.sec_unit_type = \"#\";\n        result.sec_unit_num = unitParts[3];\n      }\n    }\n  }\n  \n  // 1. Extract number (including fractions and complex formats)\n  // First try the standard pattern with space after number\n  let numberMatch = remaining.match(new RegExp(`^(${patterns.number.slice(1, -1)})(?:\\\\s+(${patterns.fraction.slice(1, -1)}))?\\\\s+(.*)$`, 'i'));\n  \n  // If no match, try to detect number immediately followed by directional (like \"48S\")\n  if (!numberMatch) {\n    const numberDirectionalMatch = remaining.match(new RegExp(`^(\\\\d+)(${patterns.directional.slice(1, -1)})\\\\s+(.*)$`, 'i'));\n    if (numberDirectionalMatch) {\n      result.number = numberDirectionalMatch[1];\n      // Set the directional as prefix and continue with remaining\n      const normalizedDirectional = DIRECTIONAL_MAP[numberDirectionalMatch[2].toLowerCase()];\n      result.prefix = normalizedDirectional || numberDirectionalMatch[2].toUpperCase();\n      remaining = numberDirectionalMatch[3] || '';\n    }\n  } else {\n    result.number = numberMatch[1];\n    if (numberMatch[2]) {\n      result.number = `${result.number} ${numberMatch[2]}`;\n    }\n    remaining = numberMatch[3] || '';\n  }\n  \n  // If no number found, try without number\n  if (!result.number && remaining) {\n    // This is just a street name without number\n    // continue processing with the full text\n  }\n  \n  // 2. Extract prefix directional (if not already extracted with number)\n  if (!result.prefix) {\n    const prefixMatch = remaining.match(new RegExp(`^(${patterns.directional.slice(1, -1)})\\\\s+(.*)$`, 'i'));\n    if (prefixMatch) {\n      const normalizedDirectional = DIRECTIONAL_MAP[prefixMatch[1].toLowerCase()];\n      result.prefix = normalizedDirectional || prefixMatch[1].toUpperCase();\n      remaining = prefixMatch[2];\n    }\n  }\n  \n  // 3. Extract secondary unit from the end (before we parse street type) or use from comma parts\n  // Use pattern from data constants\n  const secUnitMatch = remaining.match(SECONDARY_UNIT_PATTERN);\n  if (secUnitMatch) {\n    remaining = secUnitMatch[1];\n    const unitParts = secUnitMatch[2].match(UNIT_TYPE_NUMBER_PATTERN);\n    if (unitParts) {\n      if (unitParts[1] && unitParts[2]) {\n        // Standard format: \"apt 123\", \"suite 5A\", etc.\n        const rawType = unitParts[1].toLowerCase();\n        result.sec_unit_type = SECONDARY_UNIT_TYPES[rawType] || rawType;\n        result.sec_unit_num = unitParts[2];\n      } else if (unitParts[3]) {\n        // Hash format: \"#123\", \"# 123\"\n        result.sec_unit_type = \"#\";\n        result.sec_unit_num = unitParts[3];\n      }\n    }\n  } else if (secondaryUnitPart) {\n    // Use secondary unit found in comma-separated parts\n    const unitParts = secondaryUnitPart.match(UNIT_TYPE_NUMBER_PATTERN);\n    if (unitParts) {\n      if (unitParts[1] && unitParts[2]) {\n        // Standard format: \"apt 123\", \"suite 5A\", etc.\n        const rawType = unitParts[1].toLowerCase();\n        result.sec_unit_type = SECONDARY_UNIT_TYPES[rawType] || rawType;\n        result.sec_unit_num = unitParts[2];\n      } else if (unitParts[3]) {\n        // Hash format: \"#123\", \"# 123\"\n        result.sec_unit_type = \"#\";\n        result.sec_unit_num = unitParts[3];\n      }\n    }\n  }\n  \n  // 4. Special case: Check if \"East\" at the end should be treated as a street type\n  // This handles the specific case \"Music Square East\" where \"East\" becomes type \"E\"\n  const musicSquareEastMatch = remaining.match(/^(.*square)\\s+(east)\\s*$/i);\n  if (musicSquareEastMatch) {\n    result.street = musicSquareEastMatch[1].trim();\n    result.type = 'E';\n    remaining = '';\n  }\n  \n  // 5. Extract suffix directional from the end (if not handled above)\n  if (!result.type) {\n    const suffixMatch = remaining.match(new RegExp(`^(.*?)\\\\s+(${patterns.directional.slice(1, -1)})\\\\s*$`, 'i'));\n    if (suffixMatch) {\n      remaining = suffixMatch[1];\n      const normalizedDirectional = DIRECTIONAL_MAP[suffixMatch[2].toLowerCase()];\n      result.suffix = normalizedDirectional || suffixMatch[2].toUpperCase();\n    }\n  }\n  \n  // 6. Extract street type from the end (English pattern) or beginning (French pattern) - if not already set\n  if (!result.type) {\n    const streetTypeSuffixMatch = remaining.match(new RegExp(`^(.*?)\\\\s+\\\\b(${patterns.streetType.slice(1, -1)})\\\\b\\\\s*$`, 'i'));\n    const streetTypePrefixMatch = remaining.match(new RegExp(`^\\\\b(${patterns.streetType.slice(1, -1)})\\\\b\\\\s+(.*)$`, 'i'));\n    \n    if (streetTypeSuffixMatch) {\n      // English pattern: \"Main St\"\n      result.street = streetTypeSuffixMatch[1].trim();\n      result.type = normalizeStreetType(streetTypeSuffixMatch[2]);\n    } else if (streetTypePrefixMatch) {\n      // French pattern: \"Rue Main\"\n      result.type = normalizeStreetType(streetTypePrefixMatch[1]);\n      result.street = streetTypePrefixMatch[2].trim();\n    } else {\n      // No street type found, check if remaining is a number+directional (like \"400E\")\n      const numberDirectionalStreetMatch = remaining.trim().match(new RegExp(`^(\\\\d+)(${patterns.directional.slice(1, -1)})$`, 'i'));\n      if (numberDirectionalStreetMatch) {\n        result.street = numberDirectionalStreetMatch[1];\n        const normalizedDirectional = DIRECTIONAL_MAP[numberDirectionalStreetMatch[2].toLowerCase()];\n        result.suffix = normalizedDirectional || numberDirectionalStreetMatch[2].toUpperCase();\n      } else {\n        // Everything remaining is street name\n        result.street = remaining.trim();\n      }\n    }\n  }\n  \n  // Add city, state, zip\n  if (cityPart) result.city = cityPart;\n  if (statePart) result.state = statePart.toUpperCase();\n  if (zipPart) {\n    // Handle ZIP+4 format\n    if (zipPart.includes('-')) {\n      const zipParts = zipPart.split('-');\n      result.zip = zipParts[0];\n      result.zipext = zipParts[1];\n    } else {\n      result.zip = zipPart;\n    }\n  }\n  \n  // Add facility if found\n  if (facilityPart) result.facility = facilityPart;\n  \n  // Add secondary information if found\n  if (secondaryInfo) result.secondary = secondaryInfo;\n\n  // Detect country if not set\n  result.country = detectCountry(result);\n\n  // Return result if we have meaningful components\n  return (result.number || result.street) ? result : null;\n}\n\n/**\n * Parse informal addresses (fallback)\n */\nfunction parseInformalAddress(address: string, options: ParseOptions = {}): ParsedAddress | null {\n  const patterns = buildPatterns();\n  \n  // Simple fallback pattern\n  const parts = address.split(/\\s*,\\s*/);\n  if (parts.length === 0) return null;\n\n  const result: ParsedAddress = {};\n  \n  // Try to extract number from first part\n  const firstPart = parts[0];\n  const numberMatch = firstPart.match(new RegExp(`^\\\\s*${patterns.number}\\\\s+(.+)$`));\n  if (numberMatch) {\n    result.number = numberMatch[1];\n    result.street = numberMatch[2];\n  } else {\n    result.street = firstPart;\n  }\n\n  // Extract ZIP from last part\n  if (parts.length > 1) {\n    const lastPart = parts[parts.length - 1];\n    const zipMatch = lastPart.match(new RegExp(patterns.zip));\n    if (zipMatch) {\n      result.zip = zipMatch[1];\n      result.country = 'US';\n    }\n  }\n\n  return result;\n}\n\n/**\n * Normalize street type using mapping\n */\nfunction normalizeStreetType(type: string): string {\n  const normalized = type.toLowerCase().replace(/\\./g, '');\n  const mappedType = US_STREET_TYPES[normalized] || CA_STREET_TYPES[normalized];\n  \n  if (mappedType) {\n    // Use proper case mapping from data\n    return STREET_TYPE_PROPER_CASE[mappedType] || mappedType.charAt(0).toUpperCase() + mappedType.slice(1).toLowerCase();\n  }\n  \n  // Return original with proper case if no mapping found\n  return type.charAt(0).toUpperCase() + type.slice(1).toLowerCase();\n}\n\n/**\n * Parse intersection addresses \n */\nfunction parseIntersection(address: string, options: ParseOptions = {}): ParsedIntersection | null {\n  const patterns = buildPatterns();\n  \n  // Split on intersection indicators\n  const intersectionPattern = new RegExp(patterns.intersection, 'i');\n  const parts = address.split(intersectionPattern);\n  \n  if (parts.length !== 2) return null;\n\n  const result: ParsedIntersection = {};\n  \n  // Parse location info from the end of the address\n  let locationText = parts[1].trim();\n  \n  // For intersections, try to extract city/state/zip from the end differently\n  // Pattern: \"Street2Name City State ZIP\" or \"Street2Name City State\"\n  const zipMatch = locationText.match(new RegExp(`\\\\s+(${patterns.zip.slice(1, -1)})\\\\s*$`));\n  if (zipMatch) {\n    result.zip = zipMatch[1];\n    locationText = locationText.replace(zipMatch[0], '').trim();\n  }\n  \n  // Extract state from the end\n  const stateMatch = locationText.match(new RegExp(`\\\\s+(${patterns.state.slice(2, -2)})\\\\s*$`, 'i'));\n  if (stateMatch) {\n    result.state = stateMatch[1].toUpperCase();\n    locationText = locationText.replace(stateMatch[0], '').trim();\n  }\n  \n  // Extract city (1-2 words before state)\n  const cityMatch = locationText.match(/\\s+([A-Za-z]+(?:\\s+[A-Za-z]+)?)$/);\n  if (cityMatch) {\n    result.city = cityMatch[1].trim();\n    locationText = locationText.replace(cityMatch[0], '').trim();\n  }\n  \n  // Parse first street\n  const street1Text = parts[0].trim();\n  const street1Match = street1Text.match(new RegExp(\n    `^(?:(${patterns.directional.slice(1, -1)})\\\\s+)?([^\\\\s]+(?:\\\\s+[^\\\\s]+)*)\\\\s+(${patterns.streetType.slice(1, -1)})\\\\b`, 'i'\n  ));\n  if (street1Match) {\n    if (street1Match[1]) result.prefix1 = street1Match[1].toUpperCase();\n    result.street1 = street1Match[2].trim();\n    result.type1 = normalizeStreetType(street1Match[3]);\n  } else {\n    // No type found, treat entire text as street name\n    const simpleMatch = street1Text.match(new RegExp(\n      `^(?:(${patterns.directional.slice(1, -1)})\\\\s+)?(.+)$`, 'i'\n    ));\n    if (simpleMatch) {\n      if (simpleMatch[1]) result.prefix1 = simpleMatch[1].toUpperCase();\n      result.street1 = simpleMatch[2].trim();\n      result.type1 = '';\n    }\n  }\n\n  // Parse second street\n  const street2Text = locationText || parts[1].trim();\n  const street2Match = street2Text.match(new RegExp(\n    `^(?:(${patterns.directional.slice(1, -1)})\\\\s+)?([^\\\\s]+(?:\\\\s+[^\\\\s]+)*)\\\\s+(${patterns.streetType.slice(1, -1)})\\\\b`, 'i'\n  ));\n  if (street2Match) {\n    if (street2Match[1]) result.prefix2 = street2Match[1].toUpperCase();\n    result.street2 = street2Match[2].trim();\n    result.type2 = normalizeStreetType(street2Match[3]);\n  } else {\n    // No type found, treat entire text as street name\n    const simpleMatch = street2Text.match(new RegExp(\n      `^(?:(${patterns.directional.slice(1, -1)})\\\\s+)?(.+)$`, 'i'\n    ));\n    if (simpleMatch) {\n      if (simpleMatch[1]) result.prefix2 = simpleMatch[1].toUpperCase();\n      result.street2 = simpleMatch[2].trim();\n      result.type2 = '';\n    }\n  }\n\n  // Ensure we have required fields\n  if (!result.street1 || !result.street2) return null;\n\n  // Set default empty types if not found\n  if (!result.type1) result.type1 = '';\n  if (!result.type2) result.type2 = '';\n\n  return result;\n}\n\n/**\n * Parse address (compatibility alias)\n */\nfunction parseAddress(address: string, options: ParseOptions = {}): ParsedAddress | null {\n  return parseLocation(address, options);\n}\n\n/**\n * Parse informal address (compatibility export)\n */\n// NOTE: parseInformalAddress is imported from utils\n\n/**\n * Create address parser instance\n */\nfunction createParser(defaultOptions: ParseOptions = {}): AddressParser {\n  return {\n    parseAddress: (address: string, options?: ParseOptions) => \n      parseAddress(address, { ...defaultOptions, ...options }),\n    parseInformalAddress: (address: string, options?: ParseOptions) => \n      parseInformalAddress(address, { ...defaultOptions, ...options }),\n    parseIntersection: (address: string, options?: ParseOptions) => \n      parseIntersection(address, { ...defaultOptions, ...options }),\n    parseLocation: (address: string, options?: ParseOptions) => \n      parseLocation(address, { ...defaultOptions, ...options }),\n  };\n}\n\n// Export default parser instance\nconst parser = createParser();\n\nexport {\n  createParser,\n  parseAddress,\n  parseInformalAddress,\n  parseIntersection,\n  parseLocation,\n  parser,\n};\n"],"mappings":"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AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,MAAM;AAAA,EACN,OAAO;AAAA,EACP,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AAAA,EACP,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,OAAO;AAAA,EACP,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO;AAAA,EACP,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO;AAAA,EACP,OAAO;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","names":["levenshtein","parser","parser"]}